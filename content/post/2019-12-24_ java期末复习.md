---
title: java期末复习
date: 2019-12-24 21:29:26
tags: ["期末复习", "Java"]
categories: ["课程学习"]
---

## 第三章——Java 语言基础

### 标识符、注释

#### 标识符

-   由字母、 数字、下划线、 \$组成。不能由数字开头
-   不能是 Java 中的保留字(关键字)
-   大小写敏感，长度无限制

<!-- more -->

| 类型                 | 保留字                                                                                                       |
| -------------------- | ------------------------------------------------------------------------------------------------------------ |
| 类型保留字           | boolean, byte, char, short, int, long, float, double, void                                                   |
| 语句保留字           | if, else, switch, case, default, break, for, while, do, return,continue,try,catch,finally,throw,synchronized |
| 表达式保留字         | new, null, this, super                                                                                       |
| 修饰符保留字         | abstract, final, public, private, protected, static, transient, volatile                                     |
| 类、方法保留字       | class, throws, native, instanceof                                                                            |
| 扩展类构筑模块保留字 | package, import, extends, implements, interface                                                              |
| 其他保留字           | cast, futuer, generic, inner, oprater, outer, rest,var                                                       |

#### 注释

-   “//” 单行注释。表示从此向后，直到行尾都是注释。
-   “/_……_/“ 块注释。在“/_”和“_/”之间都是注释。
-   “/\*\*……\*/”文档注释。所有在“/\*\*”和“\*/”之间的内容可以用来自动形成文档。

### 变量常量

#### 变量

-   **局部变量**在使用前**必须给定初值**，否则，将编译出错，而**类成员变量无此要求**。

| 类型         | 说明                               |
| ------------ | ---------------------------------- |
| 基本数据类型 | 整数类型、实数类型、字符型、布尔型 |
| 构造数据类型 | Java 语言中构造类型用类来描述      |

> 缺省值就是默认的初值，只对成员变量有用。**局部变量没有缺省值**

#### 常量

-   数值常量
    -   整形常量：123、-15
    -   实型常量：12.1f
    -   布尔常量：true
    -   字符常量：'x'
    -   字符串类型常量："Test"
-   符号常量
    -   使用修饰符“final” 可以定义符号常量
    -   定义形式： final 类型 常量名=值;
    -   `final int a=10;`
    -   `final int a; a=10;`
    -   **类静态成员常量只能在定义时初始化**（加 static）
    -   **方法中的常量**(局部常量)可以在定义时初始化，**也可以**先定义，以后再初始化。

### 数据类型

#### 整型

-   整型常量后面加上**后缀 L 或 l**，在机器中以**long 类型**存储。

#### 实型（Double、Float）

-   一个实型常量在机器中**默认以 double 类型存储**
-   实型常量后**加后缀 F 或 f**在机器中以 float 类型存储

> 下面哪个赋值语句会产生错误?
> (A) float f=1.3 (B) char c='a'
> (C) int c=2 (D) long d=2
>
> A 错误，应加 F/f，因为实型默认为 Double 类型存储

#### 字符

```java
char c1 = 'A';
char c2 = '\u0041';
char c3 = 0x41;
//都为A字符
```

### 运算符

#### 除法

-   整数
    -   int a=10/0 运行报错
    -   int a=10%0 运行报错
-   浮点数
    -   double a=10.0/0 Infinity(正无穷大)
    -   double a=-10.0/0 -Infinity（负无穷大）
    -   double a=0.0/0 NaN
    -   double a=0.0%0 NaN

> 思考：某个培训中心要为新到的学员安排房间，假设共有 x 个学员，每个房间可以住 6 人，让你用一个公式来计算他们要住的房间数？
>
> (x+5)/6

#### 关系表达式

`boolean result = obj instanceof Class`

> 其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true，否则返回 false。

#### 数据类型转换

-   **低精度**的值赋给**高精度**的变量可以**自动转换**，不出现编译错误；**相反会出现编译错误，需要强制转换**
    -   低--->高
    -   byte(1)、short(2)、char(2)、int(4)、long(8)、float(4)、double(8)
-   如果**byte、short、char**在一起运算时，会先将这些值**转换为 int 型**，再进行运算，**结果为 int 型**。

```java
//下列代码会编译出错，提示c = (a + b)有精度损失，int转byte
class test{
    public static void main(String args[]){
        byte a = 1;
        byte b = 1;
        byte c = (a + b);
    }
}
```

-   参与运算的两个数据如果类型不一样，会先把**低级的数据转换成高级的类型**的数据后**再作运算**，**结果是高级的类型**
-   Java 中允许把 int 类型的常量赋给 byte、short、char 变量时不需要强制类型转换，反之需要

```java
byte b = 123;//合法
short s = 123;//合法
b = b + 3; //不合法，编译出错，有精度损失（都转为int计算）
```

#### 输入输出语句

```java
//从键盘读一个字符
char ch = (char)System.in.read();
```

```java
//从键盘读一个整数
try{
    byte[] buf = new byte[20];
    System.in.read(buf);
    String s = new String(buf);
    int n = Integer.parseInt(s.trim());
}
```

> trim()去除字符串左右空白
> `float f = Float.parseFloat(str.trim()); //转成单精度数` > `double d = Double.parseDouble(str.trim()); //转成双精度数`

#### 数组

```java
int[] a = {1,2,3,4};//int a[]亦可

int[] b = new int[3];
b[0] = 8;
b[1] = 9;

int[] a = new int[]{1,2,3,4};
a.length; //字符串长度length()

java.util.Arrays.sort(a);
java.util.Arrays.binarySearch(x,1);
```

## 第四章——面向对象

### 修饰符

-   **public (公共)**
    -   它修饰的类能被所有的类访问；
-   **protected (受保护)**
    -   protected 修饰的成员变量可以被本包及有继承关系的类自由访问。
-   **缺省 (默认方式)**
    -   这种类只能被**同一个包**中的类访问；
-   **private (私有)**
    -   private 修饰的成员变量**只能在同一个类中**使用。这种方式通常是最为安全的。
-   **abstract (抽象)**
    -   它修饰的类不能被实例化，**它可能包含有未实现的方法**。
-   **final (最终)**
    -   它修饰的类不能被继承，即不能有子类。
-   **extends (继承)**
    -   该保留字用来表明新创建的类继承哪个类，被继承的类称为此类的父类。extends 后面只能跟一个父类名称，因为 Java 中一个类最多能继承一个类(单继承)。
-   **implements (实现)**
    -   该保留字用来表明这个类实现了哪些接口，接口名可以有多个。

### 类、对象变量

-   static 修饰的成员变量称为类变量(静态变量)；
-   不用 static 修饰的成员变量又叫对象变量(实例变量)。

> 区别：对象变量依附于具体的对象实例，它的值因具体对象实例的不同而不同，而类变量为该类的所有对象所共享，它的值不因类的对象不同而不同。

-   访问形式
    -   **类名.成员变量**
    -   **对象名.成员变量**
    -   **成员变量**
    -   **（三种方式访问的值也相同）**

```java
class A{
    static int a, b;
}
public class B{
    public static void maim(String[] args){
        A.a = 1;
        A.b = 2;
    }
}
//无需创建对象就可以访问，也可创建
```

### 类、对象常量

无论是实例变量，还是类变量，都可以被说明成常量。final 修饰符和 static 修饰符并不冲突

-   **类常量：**一个成员变量**同时被 static 和 final 修饰**，它在类定义的所有对象中都只有唯一的值，且无法改变。
-   **一定要在定义时就给定初始值**

```java
static final x = 5; //√
static final x; x = 5; //×
```

-   **对象常量：**一个 final 成员变量，**没有 static 修饰**，不同的对象可以有不同的值
-   一定要给初始值，但可有两种方法
    -   在**定义**变量时**赋初始值**
    -   在每一个**构造函数中进行赋值**

```java
public final class FinalTest{
    public static int totalNumber = 0;     //计数的类变量
    public static final int id = 5; //一定要在定义时赋初值
    public final int total2 = 1;
    public final int total;
    public FinalTest(int x){
        totalNumber++;
        total = x; //通过构造函数给对象级的常量赋初值
        //id = 2;   //非法 不能第二次赋初值
    }
    public static void main(String[] args){
        FinalTest t1 = new FinalTest(5);
        System.out.println("t1.id： "+t1.id);
        System.out.println("t1.total： "+t1.total);
        System.out.println("FinalTest.totalNumber："+FinalTest.totalNumber);
        FinalTest t2 = new FinalTest(8);
        System.out.println("t2.id： "+t2.id);
        System.out.println("t2total： "+t2.total);
        System.out.println("FinalTest.totalNumber： "+t2.totalNumber);
        //t2.total = 5;  //一旦赋了初值就不能改变
        final int i = 10;   //使用final定义方法中局部常量
        final int j;
        j = 20;
        //j=30;   //非法，不能二次赋值
    }
}
```

### 构造方法

```java
//确保一个类只创建一个对象
class T{
    static T tObj = new T();
    private T(){

    }
    public static T getinstance(){
        return tObj;
    }
}

public class P{
    public static void main(String args[]){
        T t1= T.getinstance();
        T t2= T.getinstance();
        System.out.println(t1==t2);//true
    }
}
```

### this

this 的含义

-   在方法中，关键词 this 用来本类对象
-   在普通非静态方法中，this 表示调用这个方法的对象
-   在构造方法中，this 表示新创建的对象

```java
//构造方法中，用this调用另一构造方法
Desk(){
    Color = "";
    Length = 0;
    Width = 0;
    Height = 0;
}
Desk(String C, int L, int W, int H){
    Color = C;
    Length = L;
    Width = W;
    Height = H;
}

Desk(){
    this("", 0, 0, 0);
}
```

### 静态成员变量的继承

```java
//某类的静态成员为该类及该类的所有子类所共有
class a{
    public static int b = 10;
}

public class test extends a{
    public static void main(String args[]){
        test.b = 20;
        System.out.println(a.b);//20
    }
}
```

```java
//如果子类中新定义的静态成员变量与父类中的某个静态成员变量同名，则这两个静态成员变量相互独立。
class living{
    public static int age;
}

public class human extends living{
    public static int age;
    public static void main(String args[]){
        human.age = 20;
        System.out.println(living.age);
    }
}
```

### super

-   **代表父类对象**
-   子类隐藏了超类中的变量或方法，而在程序中又要使用超类中被隐藏的变量或方法时

```java
class living{
    public int age;
}
class human extends living{
    public int age;
    void setAge(int x, int y){
        this.age = x;
        //age=x;
        super.age = y;
    }
}
```

-   使用 super 在子类中调用父类的构造方法

```java
class Point{
    int x, int y;
    Point(int x,int y){

    }
}

class ColorPoint extends Point{
    String color;
    ColorPoint(int x,int y){
        super(x,y);//构造方法中使用super时，必须放在第一句
    }
    ColorPoint(String color, int x, int y) {
        super(x,y);
        this.color = color;
    }
}
```

```java
class A{
    A(){
        System.out.println("A()");
    }
}
class B{
    B(){
        System.out.println("B()");
    }
}
class Point{
    Point(){
        System.out.println("Point()");
    }
}
class MapPoint extends Point{
    MapPoint(){
        //隐含super();
        System.out.println("MapPoint()");
    }
}
public class ColorPoint extends MapPoint{
    A a = new A();
    B b = new B();
    ColorPoint(){
        //隐含super();
        System.out.println("ColorPoint()");
    }
    public static void main(String[] args){
        new ColorPoint();}
}
//运行结果
//Point()
//MapPoint()
//A()
//B()
//ColorPoint()
```

调用顺序：

-   首先调用父类的构造方法。这个步骤会反复递归，使继承阶层的根源最先被构建，然后是次一层的子类，直至最末一层子类为止；
-   根据各个成员的声明顺序，执行成员变量的初始化赋值
-   执行该构造方法中的各语句。

### 父类对象与子类对象的转换

Java 中父类对象和子类对象的转化需要遵循如下原则：

-   子类对象转为父类对象时，可以是显示的或隐式的，子类对象直接向父类对象赋值；
-   父类对象不能被任意的转换成某一子类的对象，只有父类对象指向的实际是一个子类对象，那么这个父类对象可以转换成子类对象，但此时必须用强制类型转换。
-   如果一个方法的形式参数定义的是父类对象，那么调用这个方法时，可以使用子类对象作为实际参数。

### 抽象类抽象方法

-   如果类中的**某一方法是抽象的**，**整个类**就必须被说明成**抽象的**。
-   抽象方法在子类中必须被实现，否则子类仍是抽象的。抽象类不是可有可无的

```java
abstract class Shape{
    abstract double area();
    abstract void draw();
}
//上述方法对一般图形无法定义其实现
class Rectangle extends Shape{
    int width;
    int length;
    public double area(){
        //矩型类实现了Shape类的抽象方法area()
        return width*length;
    }
    public void draw (){
        //矩型类实现了Shape类的抽象方法draw()
    }
}
```

### 接口

```java
[修饰符] interface 接口名[extends] [接口列表]{
    接口体
}

interface Countable{
    final int min = 5;
    void incrementCount();
    void decrementCount();
    int currentCount();
    int setCount(int newCount);
}
```

-   接口中的成员变量：都是隐含**public、static、final**的——静态最终变量（常量）

```java
int STEP = 5;
//等同于
public static final int STEP = 5;
```

-   **接口中**说明的**方法都是抽象方法**，所有方法都隐含**public 和 abstract**的

```java
int a();
public abstract int a();
```

### 包

```java
package SubClass;

package MyClass.SubClass;
//javac -d编译
```

**包的说明语句必须放在第一行**

### 比较引用类型

-   ==和!=用来比较引用型变量时,只能判断运算符两边引用的是不是同一个对象,即对象的地址值（或对象引用值）是不是相同
-   用**equls()**方法可以判断对象实体值是否相同
-   **自己定义的类**如果要支持 equals 方法必须**重写**从 Object 类继承来的**equals 方法**

```java
public boolean equals(Object obj){
    return (this==obj);
}
```

## 第五章——异常处理

### 举例

-   除 0 溢出（ArithmeticException）
-   文件找不到（FileNotFoundException）
-   数组元素下标越界（ArrayIndexOutofBoundsException）

### 捕获异常

```java
try{

}catch(Exception e){

}finally{

}
```

### 声明抛出

-   调用的方法出现了异常
-   检测出**throw**语句

```java
import java.io.*;
public class NonRuntimeExceptionDemo1{
    public static void main(String args[]) throws Exception{
        FileInputStream in = new FileInputStream("text.txt");
        int s;
        while((s = in.read())!=-1)
            System.out.print(s);
        in.close();
    }
}
```

```java
import java.io.*;
public class Test {
    public String getInput() throws IOException{
        IOException ae = new IOException("buffer is full");
        throw ae;
    }
}
```

-   当下面的程序的输入是“1 2 3 4”时，程序的输出是什么，如果把的 xxxxxxxxxxx 的 catch 语句去掉，输出是什么？
-   hbcdxn
-   hcmn

```java
public class Child{
    public static void main(String args[]){
        try{
            System.out.print('h');
            mb_method1(args);
            System.out.print('x');
        }catch(Exception e){
            System.out.print('m');
        }
        System.out.print('n');
     }//方法main结束

     static void mb_method1(String a[]){
        try{
            mb_method2(a);
            System.out.print('a');
        }catch(Exception e){//xxxxxxxxxxx
            System.out.print('b');
        }
        finally{
                System.out.print('c');
        }
          System.out.print('d');
    }//方法mb_method1结束

    static void mb_method2(String a[]){
        System.out.println(a[a.length]);
    }//方法mb_method2结束

}//类J_Test结束
```

## 第六章——Java.lang

-   常用类

    -   Object、Class、Math、System、Runtime、Thread、Throwable

-   java 中自动导入了 java 语言包

### 字符串类

-   String 类 ：不可改变的静态字符串

-   StringBuffer 类：动态可变的字符串

```java
String a = "java";
//仅放入字符串池
String b = new String("java");
//若字符串池中有，则仅在堆内存创建
String c = new String("Hello");
//若字符串池中无，则创建，也在堆内存中创建
```

```java
String a = "hello";
String b = "hello";
a.equals(b);//true
a == b;//true

String a = new String("hello");
String b = new String("hello");
a == b;//false

String a = "hello";
String b = new String("hello");
a.equals(b);//true
a == b;//false
```

```java
String a = "hellojava";
String b = "java";
String c = "hello"+b;
a == c;//false，仅在编译时对字符串池中相同的字符串合并
a.equals(c);//true
```

### 字符串方法

```java
String a = "hello";
String c = a.substring(2,3);//得到“l”
int b = a.length();//得到5
char b = a.charAt(0);//得到下标为0的字符，得到字符h
char[] b = a.toCharArray();//{'h','e','l','l','o'}

char [] a = {'a','b','c','d'};
String b = new String(a);

byte [] a = {65,66,67,68};
String b = new String(a);//得到ABCD

String s1 = "Hello";
String s2 = s1.toUpperCase();//得到“HELLO”
String s3 = s1.toLowerCase();//得到“hello”
```

### StringBuffer 类

```java
public StringBuffer()；
public StringBuffer(int length)；
public StringBuffer(String str)；
```

#### 方法

```java
StringBuffer s = new StringBuffer("hello");
s.append("java");//s变为“hellojava”
s.insert(5,"sun"); // s变为“hellosunjava”
s.setCharAt(0,'H'); // s变为“Hellosunjava”
s.delete(5,8);// s变为“Hellojava”
s.toString();//转为String类
s.charAt(0);//h

System.out.println('a'+1);//98，char转为int
```

### 数据类型转换

-   将字符串转换为 int 型

```java
String s = "1234";
int i = Integer.parseInt(s);
```

-   将 int 型转换为字符串

```java
int i = 1234;
String s = Integer.toString(i);
//其他Double, Float等数据类型类以此类推
```

### Math 类

```java
pow(double x, double y); //返回x的y次方。
exp(double x);  //返回ex
log(double x);  //返回x的自然对数。
sqrt(double x);  //返回x的平方根。
//（返回类型均为double型）
```

```java
//下面了解即可
ceil(double a); //返回大于或等于a的最小整数值。
floor(double a);//返回小于或等于a的最大整数值。
rint(double a); //返回四舍五入后的整数值。
//（上面三个方法的返回类型均为double型）
round(float a);//返回四舍五入后的整数值, 返回类型为int型。
round(double a);//返回四舍五入后的整数值, 返回类型为long型。

Math.min(a, b);
Math.max(a, b);
```

## 第六章——java.util

### 日期类

-   了解

```java
//构造方法
public Date();
public Date(int year, int month, int date);
public Date(int year, int month, int date, int hours,int minutes);
public Date(int year, int month, int date, int hours,int minutes,int seconds);
```

```java
//方法
public int getYear();
public int getMonth();
public int getDate();
public int getDay();
public int getHours();
public int getMinutes();
public int getSeconds();
public boolean before(Date when);
```

```java
//日期的比较
public boolean before(Date when);
public boolean after(Date when);
public boolean equal(Object obj);
```

### 向量类

```java
//构造方法:
Vector(int capacity, int capacityIncrement);
//capacityIncrement缺省为0，表示扩充1倍大小
//否则，表示增加多少容量
Vector(int capacity);
Vector();

Vector<元素类型> 向量名称 = new Vector<元素类型>(容量);
Vector<String> vector1 = new Vector<String>(5);
//这里的元素类型不能是基本数据类型
```

```java
//方法
boolean add(E e);
vector1.add("姚明");
E elementAt(int index);
vector1.elementAt(0);

vector1.capacity();//向量的容量
vector1.size();//向量中的元素个数
```

```java
//往向量中插入元素
void insertElementAt(E obj, int index);

//修改向量中的元素
void setElementAt(E obj, int index);

//删除向量中的元素
vector1.removeElementAt(1);//删除下标为1的元素

//清空向量
vector1.clear(); //向量中的所有元素都被删除

//判断向量中是否有与某对象等值的对象 
boolean contains(Object o);
vector1.contains("张三");

//查找特定元素在向量中的下标位置
int indexOf(Object o);
System.out.println(vector1.indexOf("张三")); //得到0
```

### Stack

```java
//栈类定义的主要方法如下：
Stack();     //栈类构造方法
E push(E item);   //把对象压入栈
E pop(); //从栈顶弹出一个对象
E peek(); //读栈顶一个对象，但不弹出
boolean empty(); //测试栈是否为空, 是则返回True, 否则返回False
```

## 第六章——java.io

|       方法       |       说明       |
| :--------------: | :--------------: |
|   InputStream    | 字节输入流的超类 |
|   OutputStream   | 字节输出流的超类 |
|      Reader      | 字符输入流的超类 |
|      Writer      | 字符输出流的超类 |
|       File       |      文件类      |
| RandomAccessFile |  随机访问文件类  |

### 字节流

```java
//InputStream和OutputStream
public int read() throws IOException
public int read( byte[] b ) throws IOException
public int read( byte[] b, int off, int len ) throws IOException

void write(int b) throws IOException
void write( byte[] b ) throws IOException
void write( byte[] b, int off, int len ) throws IOException
```

### 字符流

```java
//Reader和Writer
public int read() throws IOException
public int read(char[] cbuf) throws IOException
public int read(char[] cbuf,int off,int len) throws IOException

void write(String str) throws IOException
void write(char[] cbuf) throws IOException
void write(char[] cbuf,int off,int len) throws IOException
```

### 读入

```java
char c = (char)System.in.read();
System.out.println(c);
//如果输入‘你’，则输出?
//因为相当于读取了字符‘你’的高位字节，并未读取完整的汉字
//因此需要将字节流转换为字符流。
InputStreamReader isr = new InputStreamReader(System.in);
try{
    c = (char)isr.read();
    System.out.println(c);
}catch(IOException e){

}
```

### File 类

```java
File(String pathname);
File(File parent, String child);
File(String parent, String child);
File(URI uri);
//File(文件/目录)
```

```java
//创建文件
File f1 = new File("H:\\a.txt");
boolean success = f1.createNewFile();

//创建目录
File f1 = new File("H:\\a");
boolean success = f1.mkdir();

public boolean renameTo(File dest);
//文件重命名。
public boolean delete();
//删除文件或空目录。

public String[] list();
//返回目录中的所有文件名字符串。
public File[] listFiles();
//返回目录中的所有文件对象。

public boolean exists();
```

```java
//举例：利用接口java.io.FilenameFilter和File类list方法，
//实现一个文件过滤器，把某个目录下的所有以.java结尾的文件都找出来
import java.io.*;

class DirFilter implements FilenameFilter{
    String extn;
    public DirFilter(String extn){
        this.extn = extn;
    }
    public boolean accept(File dir,String name){
        boolean isAccept;
        if(name.indexOf(extn) == -1)
            isAccept = false;
        else
            isAccept = true;
        return isAccept;
    }
}

// 下面的程序利用上述过滤器找出当前目录下面指定类型（文件名中含有.java的文件）
import java.io.*;

public class DirList {
    public static void main(String[] args) {
        try {
            File file = new File(". ");
            String[] list = file.list(new DirFilter(".java"));
            // 得到当前路径下所有文件名含有.java的文件
            for (int i = 0; i < list.length; i++)
                System.out.println(list[i]);
        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }
}
```

### FileInputStream 和 FileOutputStream

#### FileInputStream

```java
FileInputStream fs = new FileInputStream("a.txt");
File file = new File ("a.txt");
FileInputStream fs = new FileInputStream(file);
fs.readLine();
```

#### FileOutputStream

```java
//构造方法
FileOutputStream(File file);
FileOutputStream(File file, boolean append);
FileOutputStream(FileDescriptor fdObj);
FileOutputStream(String name);
FileOutputStream(String name, boolean append);

//写入字节的方法
void write(byte[] b);
void write(byte[] b, int off, int len);
void write(int b);
```

### 过滤流

```java
FileInputStream in = new FileInputStream("a.txt");
BufferedInputStream bufin = new BufferedInputStream(in);
```

### 字符流

#### FileReader

```java
// 构造方法
File f = new File("d:\\t1.txt");
FileReader f1 = new FileReader(f);
FileReader f2 = new FileReader("d:\\t1.txt");

// 重要方法
read();
read(char b[]);
read(char b[], int off, int len);
close();
```

#### FileWriter

```java
// 构造方法
File f = new File("d:\\t1.txt");
FileWriter f1 = new FileWriter(f);
FileWriter f2 = new FileWriter("d:\\t1.txt");

// 重要方法
write(char c);
write(char b[]);
write(char b[], int off, int len);
close();

```

```java
//以行为单位从一个文件读取数据
//FileReader通过BufferedReader封装，就可以调用readline()一行行读出文件内容
BufferedReader in = new BufferedReader(new FileReader("F:\\nepalon\\TestIO.java"));
String s;
while((s = in.readLine()) != null)
    System.out.println(s);
in.close();
```

```java
//以字符为单位接收键盘的输入
BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
System.out.println(“Enter a line:” );
System.out.println(stdin.readLine());
```

```java
//向一个文件写数据
//FileWriter通过PrintWriter封装，就可以调用print()和println()轻松向文件写入内容
try{
    FileWriter fw = new FileWriter("F:\\nepalon\\TestIO.out")
    PrintWriter out1 = new PrintWriter(new BufferedWriter(fw));
    int lineCount = 1;
    out1.println(" We are good friends!!!" );
    out1.close();
}catch(EOFException ex){
    System.out.println("End of stream");
}
```

## 第七章——图形界面

-   `javax.swing.*`Swing GUI 组件
-   `java.awt.event.*`组件事件类
-   `java.awt.*`布局类、颜色、画图

```java
import javax.swing.*;

public class SwingExample1 {

    public static void main(String args[]) {
        JFrame frame = new JFrame();
        frame.setLayout(null);
        JLabel jLabelWelcome = new JLabel();
        jLabelWelcome.setText("欢迎");
        jLabelWelcome.setBounds(40, 30, 450, 30);
        frame.add(jLabelWelcome);
        frame.setTitle("第一个Swing程序");
        frame.setBounds(330, 250, 500, 150);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

-   JButton、JTextField、JLabel

### 容器组件

-   顶级容器：JFrame、JDialog、JWindow
    -   默认布局：BorderLayout
    -   North、South、West、East
-   其他容器：JPanel、JToolBar
    -   默认布局：FlowLayout

#### JFrame

```java
show(); //显示框架
setVisible(boolean b); //使框架可见/不可见(true/false)
hide(); //隐藏框架
setLayout(new FlowLayout());//设置布局
setTitle(String s); //设置框架的标题
setSize(int w, int h); //调整框架的尺寸(宽/高为w/h)
setBounds(int x, int y, int w,int h); //调整框架的位置及尺寸(左上角为(x,y), 宽、高为w、h)
add(Component ob); //将其它组件ob加入到框架的中心位置
add(String p, Component ob); //将组件ob加入到框架的p位置
```

#### Dialog

```java
Frame f = new Frame();
Dialog d = new Dialog(f, "Error");
d.setVisible(true);
```

#### Panel

-   必须放在顶层容器中

```java
Frame f = new Frame();
Panel p = new Panel();
p.setBackGround(Color.yellow);//设置颜色
p.add(new JButton("Down"));
d.add(p);
```

### 常用组件

#### Button

```java
Button();
Button(String label);

setLabel(String label);
getLabel();
addActionListener(ActionListener l); //将l指定为按钮的监听者
setEnabled(true/false);
```

#### Label

```java
Label();
Label(String text);

getText();
setText(String text);
```

#### TextField

```java
TextField();
TextField(Sring text);

addActionListener(ActionListener l);
setText(String s);
getText();
```

### 事件处理

```java
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;

public class Demo extends JFrame {
    JTextField jiashu1;
    JTextField jiashu2;
    JTextField he;
    JButton jiafa;

    public Demo() {
        setLayout(new FlowLayout());
        JTextField jf = new JTextField(5);
        JButton jb = new JButton("修改");
        add(jf);
        add(jb);
        setLocation(300, 300);
        setSize(400, 300);
        jb.addActionListener(new MyActionListener(jf));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        d.setVisible(true);
    }
}

class MyActionListener implements ActionListener {
    JTextField he;

    public MyActionListener(JTextField he) {
        this.he = he;
    }

    public void actionPerformed(ActionEvent e) {
        he.setText("change");
    }
}
```

#### 事件对象

-   MouseEvent
    -   鼠标事件：鼠标单击，移动
-   WindowEvent
    -   窗口事件：关闭窗口，窗口闭合，图标化
-   KeyEvent
    -   键盘事件：键按下、释放
-   ActionEvent
    -   动作事件：按钮按下，TextField 中按 Enter 键

#### 事件监听器

| 事件监听器          | 响应函数                                        |
| ------------------- | ----------------------------------------------- |
| MouseListener       | mouseCliked/mouseEnter/mouseExited/mousePressed |
| MouseMotionListener | mouseMoved/mouseDragged                         |
| WindowListener      | windowOpened/windowClosing                      |
| ActionListener      | actionPerformed                                 |

> 大多数事件监听器都有对应的适配器，例如：WindowListener 的适配器是 WindowAdapter
>
> **只有 ActionListener 没有适配器**

```java
class MyWindowAdapter extends WindowAdapter{
    public void windowClosing(WindowEvent e){

    }
}

class MyActionListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {

    }
}
```

### 美化

```java
setBackGround(Color.blue);
serForeground(new Color(200,100,0));
setFont(new Font("黑体",Font.ITALIC,30));
```

### 图形

```java
public void paint(Graphics g);
public void repaint();
```

```java
class MyComponent extends JComponent{
    public void paint (Graphics g){
        //code for drawing
    }
}
MyComponent m = new MyComponet();
add(m);
```

```java
import java.awt.*;

public class Rect extends Frame {
    public void paint(Graphics g) {
        g.setColor(Color.orange); // 设置绘图颜色
        g.drawRect(10, 40, 100, 60);
        g.fillRect(120, 40, 100, 60);
    }

    public static void main(String args[]) {
        Rect f = new Rect();
        f.setTitle("It's Rect!");
        f.setSize(230, 120);
        f.setVisible(true);
    }
}
```

#### 方法

-   drawString
    -   画字
    -   `drawString(String s)`
-   drawLine
    -   画线
    -   `drawLine(x1,y1,x2,x2)`，分别为起始结束点
-   drawRect
    -   画矩形
    -   `drawRec(x,y,w,h)`，xy 为左上角点，wh 为宽度和长度
-   drawOval
    -   画圆
    -   `drawOval(x,y,w,h)`，矩形内接圆
-   drawArc
    -   画弧
    -   `drawArc(x,y,w,h,s,arcAngle)`，s 为起始角度，arcAngle 为跨越度数

## 第九章——多线程

### 实现机制

`java.lang.Thread`

`java.lang.Runnable`

-   声明一个 Thread 类的子类，并覆盖 run() 方法

    ```java
     class mythread extends Thread{
        public void run(){
            /* 覆盖该方法*/
        }
     }
    ```

-   声明一个实现 Runnable 接口的类，并实现 run() 方法

    ```java
     class mythread implements Runnable{
         public void run(){
             /* 实现该方法*/
         }
     }
    ```

#### Thread 方法

-   编写一个简单的程序，要求它按两个不同的时间间隔（ 1 秒和 3 秒）在屏幕上连续显示当前时间。

```java
import java.util.*;

class TimePrinter extends Thread {

    int pauseTime;
    String name;

    public TimePrinter(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public void run() {
        while (true) {
            try {
                System.out.println(name + ":" + new Date(System.currentTimeMillis()));
                Thread.sleep(pauseTime);
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    }

    public static void main(String args[]) {
        TimePrinter tp1 = new TimePrinter(1000, "Fast Guy");
        tp1.start();
        TimePrinter tp2 = new TimePrinter(3000, "Slow Guy");
        tp2.start();
    }
}
```

#### Runnable 方法

```java
import java.util.*;

class TimePrinter implements Runnable {

    int pauseTime;
    String name;

    public TimePrinter(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public void run() {
        while (true) {
            try {
                System.out.println(name + ":" + new Date(System.currentTimeMillis()));
                Thread.sleep(pauseTime);
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    }

    public static void main(String args[]) {
        Thread t1 = new Thread(new TimePrinter(1000, "Fast Guy"));
        t1.start();
        Thread t2 = new Thread(new TimePrinter(3000, "Slow Guy"));
        t2.start();
    }
}
```

### Thread 类

```java
Thread.sleep(1000);
new Thread().start();
setPriority();//1-10，10最紧急
```

### 同步互斥

```java
synchronized void f( ) {
    /*…*/
}
synchronized void g( ) {
    /*…*/
}
```

-   设计两个线程，其中一个线程 IncThread，工作流程为循环 10 次，每次对共享变量 J 增加 1（函数为 inc()），另外一个线程 DecThread，工作流程为循环 10 次，每次对共享变量 J 减少 1(函数为 dec())，在主程序中启动两个线程进行并发执行。在改写数据过程中利用同步机制保障数据的一致性

```java
class Data {
    int i = 0;

    public synchronized void inc() {
        i++;
        System.out.println(i);
    }

    public synchronized void dec() {
        i--;
        System.out.println(i);
    }
}

class IncThread extends Thread {
    Data d;

    IncThread(Data d) {
        this.d = d;
    }

    public void run() {
        for (int i = 0; i < 10; i++) {
            this.d.inc();
        }
    }
}

class DecThread extends Thread {
    Data d;

    DecThread(Data d) {
        this.d = d;
    }

    public void run() {
        for (int i = 0; i < 10; i++) {
            this.d.dec();
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Data d = new Data();
        new IncThread(d).start();
        new DecThread(d).start();
    }
}
```

## 第十章——网络编程

`java.net.*`

### TCP 通信

-   服务方

```java
import java.io.*;
import java.net.*;

public class TcpServer {
    static public void main(String args[]) throws IOException {
        ServerSocket svrsoc = null;
        Socket soc = null;
        BufferedReader in = null;
        PrintStream out = null;
        try {
            svrsoc = new ServerSocket(8000); // 构造rverSockets对象，端口为8000
            soc = svrsoc.accept(); // 服务者等待一个连接，返回新套接口soc
            in = new BufferedReader(new InputStreamReader(soc.getInputStream()));
            out = new PrintStream(soc.getOutputStream());// 在新套接口soc上构造 // PrintStream对象out
            InetAddress clientIP = soc.getInetAddress(); // 得到顾客方IP地址
            System.out.println("Client's IP address:" + clientIP);
            out.println("Welcome!...");
            String str = in.readLine(); // 在in上读一行
            while (!str.equals("quit")) {
                // 如读出的不是“quit”,继续读
                System.out.println("Client said:" + str);
                str = in.readLine();
            }
            System.out.println("Client want to leave.");
        } catch (Exception e) {
            System.out.println("Error:" + e);
        } finally {
            in.close();
            out.close();
            soc.close();
            svrsoc.close();
        }
    }
}
```

-   客户方

```java
import java.net.*;
import java.io.*;

public class TcpClient {
    static public void main(String args[]) throws IOException {
        Socket soc = null;
        BufferedReader in = null;
        PrintWriter out = null;
        String strin = null;
        try {
            soc = new Socket("localhost", 8000);
            System.out.println("Connecting to the Server...");
            in = new BufferedReader(new InputStreamReader(soc.getInputStream()));
            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(soc.getOutputStream())), true);
            strin = in.readLine();
            System.out.println("Server said:" + strin);
            byte bmsg[] = new byte[20];
            System.in.read(bmsg);
            String msg = new String(bmsg);
            msg = msg.trim();
            out.println(msg);
            while (!msg.equals("quit")) {

                System.in.read(bmsg);
                msg = new String(bmsg);

                msg = msg.trim();
                out.println(msg);
                // System.out.println(msg);
            }
            // out.println(strout);
        } catch (Exception e) {
            System.out.println("Error: " + e);
        } finally {
            in.close();
            out.close();
            soc.close();
            System.exit(0);
        }
    }
}

```
