---
title: Java Web初探
date: 2020-11-14 21:33:03
tags: [Java Web,]
categories: [后端]
---

## 01-Servlet基础

### servlet

- 什么是servlet
  - 运行在Servlet容器/Web应用服务/Tomcat，负责与客户端进行通信
- servlet功能
  - 创建并返回基于客户请求的动态HTML页面
  - 与数据库进行通信
- 如何使用
  - servlet本身是一组接口，自定义一个类，并且实现servlet接口，这个类就具备接受客户端请求以及做出响应的功能。

<!-- more -->

```java
package com.iot.servlet;

import javax.servlet.*;
import java.io.IOException;

public class MyServlet implements Servlet {
    @Override
    public void init(ServletConfig var1) throws ServletException {}
    
    @Override
    public ServletConfig getServletConfig() {
        return null;
    }
    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        System.out.println("我是servlet");
    }
    @Override
    public String getServletInfo() {
        return null;
    }
    @Override
    public void destroy() {}
}
```

浏览器不知能直接访问servlet，需要配置映射访问

- 基于xml映射（web.xml）

- ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
      <servlet>
          <servlet-name>myservlet</servlet-name>
          <servlet-class>com.iot.servlet.MyServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>myservlet</servlet-name>
          <url-pattern>/myservlet</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 基于注解

- ```jaVA
  @WebServlet("/myservlet")
  public class MyServlet implements Servlet {}
  ```

### req与res

```java
@Override
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
    System.out.println("我是servlet");
}
```

#### 乱码问题

```java
@Override
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
    req.setCharacterEncoding("UTF-8");  // 请求中文
    System.out.println("我是servlet");
    res.setContentType("text/html;charset=UTF-8");  // 响应中文
    res.getWriter().write("哈哈");
}
```

### servlet生命周期

1. 当浏览器访问Servlet的时候，Tomcat 会查询当前Servlet的实例化对象是否存在，如果不存在，则通过反射机制动态创建对象。如果存在，直接执行第3步。
2. 调用init完成初始化。
   1. ServletConfig：用来描述Servlet的基本信息
   2. getServletName() 返回servlet的名称，全类名（带包名）。
   3. getInitParameter(String key) 获取init参数（web.xml中配置）。
   4. getInitParameterNames() 返回所有initParameter的name值。
   5. getServletContext() 返回ServletContext对象，它是Servlet的上下文，整个Servlet的管理者。
3. 调用service完成业务逻辑操作（可以多次调用）。
4. 关闭tomcat会调用destroy方法，释放资源。

### Servlet层次结构

Servlet->GenericServlet->HttpServlet

### HttpServlet

```java
@WebServlet("/demo1")
public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html;charset=UTF-8");
        resp.getWriter().write("哈哈");
    }
}
```

## 02-JSP基础

JSP本质上是一个Servlet，JSP主要负责与用户交互，将最终的界面呈现给用户，HTML+JS+CSS+Java的混合文件。

当服务器接收到一个jsp请求时，将该请求交给jsp引擎去处理，每一个jsp页面第一次被访问的时候，jsp引擎会将他翻译成一个servlet文件，再由web容器调用servlet完成响应。

具体嵌入方式中：

1. jsp脚本，执行Java逻辑代码

```jsp
<%
    System.out.println(test());
%>
```

2. jsp声明，定义Java方法

```jsp
<%!
    public String test(){
        return "Hello";    
    }
%>
```

3. jsp表达式，把Java对象直接输出到HTML页面中

```jsp
<%=Java表达式%>
```

### jsp的9个内置对象

1. **request**：表示一次请求，HttpServletRequest
2. **response**：表示一次响应，HttpServletResponse
3. **pageContext**：页面上下文，获取页面信息，PageContext
4. **session**：表示一次会话，保存用户信息，HttpSession
5. **application**：当前web应用，全局对象，保存所有用户的共享信息，ServletContext
6. config：当前jsp对应的Servlet的ServletConfig对象，获取当前Servlet信息
7. out：向浏览器输出数据，JspWriter
8. page：当前jsp对应的Servlet，Servlet
9. exception：jsp页面发生的异常，Exception

#### request常用方法

1.  `String getParameter(String key)`：获取客户端传来的参数
2.  `void setAttribute(String key, Object value)`：通过键值对的形式保存数据
3.  `Object getAttribute(String key)`：通过key取出value
4.  `RequestDispatcher getRequestDispatcher(String path)`：返回一个对象，该对象的forward用于转发请求（服务端跳转）
5.  `String[] getParameterValues()`：获取客户端传来的多个同名参数
6.  `void setCharacterEncoding(String charse)`：指定每个请求的编码

#### response常用方法

1. `sendRedirect(String path)`：重定向，页面之间的跳转（客户端跳转）

#### session

- 实现会话两种方法
  - session
  - cookie

#### session常用方法

- `String getId()`：获取sessionID

- `void setMaxInactiveInterval(int interval)`：设置session失效时间，单位为秒
- `int getMaxInactiveInterval()`：获取失效时间
- `void invalidate()`：设置session立即失效
- `void setAttribute(String key, Object value)`
- `Object getAttribute(String key)`
- `void removeAttribute(String key)`

#### cookie

服务端在HTTP响应中附带传给浏览器的一个小文本文件，一旦浏览器保存了某个cookie，在之后的请求和响应中，会将此cookie来回传递，这样就可以通过cookie这个载体完成客户端和服务端的数据交互。

```java
Cookie cookie = new Cookie("name","zhangsan");
response.addCookie(cookie);
```

```jsp
<%
    Cookie[] cookies = request.getCookies();
    for (Cookie cookie : cookies) {
        System.out.print(cookie.getName() + "=");
        System.out.println(cookie.getValue());
    }
%>
```

#### cookie常用方法

- void setMaxAge(int age)：设置有效时间，单位为秒
- int getMaxAge()：获取有效时间，默认为-1
- String getName()：获取name
- String getValue()：获取value

#### session和cookie区别

- session
  - 保存在服务器
  - 保存的数据是object
  - 会随着会话的结束而销毁
  - 保存重要信息
- cookie
  - 保存在浏览器
  - 保存的数据是String
  - 可以长期保存，与会话无关
  - 保存不重要信息



## 03-JSP内置对象作用域

### 作用域

page<request<session<application

page只在当前页面有效

request在一次请求中有效

session在一次会话中有效

application对应整个web应用

### EL表达式

Expression Language表达式，替代JSP页面中数据访问时的复代码，`${表达式}`

可以非常便捷的取出域对象（pageContext、request、session、application）中保存的数据，前提是一定要先setAttribute

```jsp
<%
    request.setAttribute("pk","123");
%>
${pk}
```

- EL对4钟域对象的默认查找顺序：pageContext->request->session->application，找到立即返回
- 指定作用域查找：
  - pageContext：`${pageScope.name}`
  - request：`${requestScope.name}`
  - session：`${sessionScope.name}`
  - application：`${applicationScope.name}`

#### EL执行表达式

&&（and）、||（or）、!（not）、==（eq）、!=（ne）等

${empty test}，empty判断，长度0（String、集合）为ture

### JSTL

JSP为开发者提供的一系列标签，可以完成一些逻辑处理。JSTL与EL结合使用，使代码简洁。

- JSTL使用
  - 导入jar包（jstl.jar、standard.jar）[下载地址](http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/)
  - 在JSP页面开始的地方引入，`<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>`
  - 在需要的地方使用

- 优点
  - 提供了统一的标签
  - 可以用于编写各种动态功能
- 常用标签
  - set、out、remove、catch
- set：向域对象（默认pageContext）添加数据

```jsp
<%
    xxx.setAttribute(k, v);
%>
等价于
<c:set var="name" value="name"></c:set>
向request中添加
<c:set var="name" value="name" scope="request"></c:set>
修改属性
<c:set target="${user}" property="name" value="李四"></c:set>
```

```jsp
<c:out value="${name}" default="未定义"></c:out>
```

- catch：捕获异常

```jsp
<c:catch var="error">
    <%
        int a = 10/0;
    %>
</c:catch>
${error}
```

- 条件标签：if、choose-when

```jsp
<c:if test="${num1 > num2}">ok</c:if>
无else
<c:if test="${num1 <= num2}">fail</c:if>

<c:choose>
    <c:when test="${num1>num2}">1</c:when>
    <c:when test="${num1<num2}">2</c:when>
    <c:otherwise>3</c:otherwise>
</c:choose>
```

- 迭代标签：forEach

```jsp
<c:forEach items="${list}" var="user">
    ${user.name}
</c:forEach>

<%--[2, 3]--%>
<c:forEach items="${list}" var="user" begin="2" end="3" step="1">
    ${user.name}
</c:forEach>

<c:forEach items="${list}" var="user" varStatus="sta">
    ${sta.index}-${user.name}
</c:forEach>
```

- 格式化标签库常用的标签：时间格式化、格式化数字

```jsp
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

<%
    request.setAttribute("date", new Date());
%>
<fmt:formatDate value="${date}" pattern="YYYY-mm-dd hh:mm:ss"></fmt:formatDate>

<fmt:formatNumber value="1234.567" maxIntegerDigits="2" maxFractionDigits="2"></fmt:formatNumber>
<%--34.57--%>
```

- 函数标签库常用的标签：

```jsp
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>

<%
    request.setAttribute("info", "Java,C");
%>
${fn:contains(info, "python")}  <%-- false --%>
${fn:startsWith(info, "Java")}  <%-- true --%>
${fn:indexOf(info, "va")}  <%-- 2 --%>
```

## 04-过滤器

- 功能
  - 用来拦截传入的请求和传出的响应
  - 修改或以某种方式处理正在客户端和服务端之间交换的数据流
- 如何使用
  - 与使用Servlet类似，Filter是java web提供的一个接口，只需定义一个类并且实现该接口。

```java
package com.iot.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain fc) throws IOException, ServletException {
        req.setCharacterEncoding("utf-8");
        res.setContentType("text/html;charset=UTF-8");
        fc.doFilter(req, res);  // 继续向后处理
    }
}
```

```java
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String username = req.getParameter("username");
        System.out.println(username);
        resp.getWriter().write("哈哈");
    }
}
```

web.xml配置

```xml
<filter>
    <filter-name>charcater</filter-name>
    <filter-class>com.iot.filter.CharacterFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>charcater</filter-name>
    <url-pattern>/login</url-pattern>
    <url-pattern>/test</url-pattern>
</filter-mapping>
```

### filter生命周期

当配置多个filter时，根据在web.xml中的顺序来访问（注解@WebFilter不按顺序）

```java
@WebFilter("/login")
public class CharacterFilter implements Filter {}
```

- 实际开发中filter使用场景
  - 统一处理中文乱码
  - 屏蔽敏感词
  - 控制资源访问权限

## 05-文件上传下载

### 上传

- JSP
  - input的type设置为file
  - form表单的method设置为post，get只会传文件名
  - form的enctype设置为`multipart/form-data`，二进制传递数据

- servlet

底层写法

```java
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
    // 输入流获取客户端传来的数据
    InputStream inputStream = req.getInputStream();
    Reader reader = new InputStreamReader(inputStream);
    BufferedReader bufferedReader = new BufferedReader(reader);

    // 通过输出流将数据输出到本地
    String path = req.getServletContext().getRealPath("file/copy.txt");
    OutputStream outputStream = new FileOutputStream(path);
    Writer writer = new OutputStreamWriter(outputStream);
    BufferedWriter bufferedWriter = new BufferedWriter(writer);
    String str = "";
    while ((str=bufferedReader.readLine())!=null){
        System.out.println(str);
        bufferedWriter.write(str);
    }

    bufferedWriter.close();
    writer.close();
    outputStream.close();
    bufferedReader.close();
    reader.close();
    inputStream.close();
}
```

FileUpload组件

可以将所有请求信息解析成FileItem对象，可以通过对FileItem对象操作完成上传，面向对象思想。

```java
public class UploadServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
        ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory);
        try {
            List<FileItem> list = servletFileUpload.parseRequest(req);
            for (FileItem fileItem : list) {
                if (fileItem.isFormField()) {
                    // 表单文件
                    String name = fileItem.getFieldName();
                    String value = fileItem.getString("UTF-8");
                    System.out.println(name + ": " + value);
                } else {
                    String fileName = fileItem.getName();
                    long size = fileItem.getSize();
                    System.out.println(fileName + ": " + size + "B");
                    InputStream inputStream = fileItem.getInputStream();
                    String path = req.getServletContext().getRealPath("file/" + fileName);

                    OutputStream outputStream = new FileOutputStream(path);
                    int t = 0;
                    while ((t = inputStream.read()) != -1) {
                        outputStream.write(t);
                    }
                    // close
                }
            }
        } catch (FileUploadException e) {
            e.printStackTrace();
        }
    }
}
```

### 下载

```java
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        // 设置相应方式
        resp.setContentType("application/x-msdownload");
        String filename = "109.jpg";
        // 设置下载之后的文件名
        resp.setHeader("Content-Disposition", "attachment;filename=" + filename);
        // 获取输出流
        OutputStream outputStream = resp.getOutputStream();

        String path = req.getServletContext().getRealPath("file/" + filename);
        InputStream inputStream = new FileInputStream(path);
        int t = 0;
        while ((t = inputStream.read()) != -1) {
            outputStream.write(t);
        }
        inputStream.close();
        outputStream.close();
    }
}
```

## 06-异步Ajax请求

Ajax是一种交互方式，异步加载，客户端和服务端的数据交互更新在局部页面的技术，不需要刷新整个页面

优点：

1. 局部刷新，效率更高
2. 用户体验更好



## 07-JDBC

### JDBC体系结构

接口包括两个层面

- 面向应用的API，供开发者调用（JDBC API）
- 面向数据库的API，供厂商开发数据库的驱动（JDBC Driver Manager）

#### JDBC API

java.sql和javax.sql

- DriverManager类
- Connection接口
- Statement接口
- ResultSet接口

#### Driver Manager

管理不同的JDBC驱动，负责连接不同的数据库

### JDBC使用

1. 加载数据库驱动，Java程序和数据库之间的桥梁
2. 获取Connection，Java程序与数据库的一次连接
3. 创建Statement对象，由Connection产生，执行SQL语句
4. 如果需要接受返回值，创建ResultSet对象，保存Statement执行之后的查询结果

```java
public class Test {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        String url = "jdbc:mysql://xxxxx:3306/cumt_funding";
        String username = "cumt_funding";
        String password = "xxxxxxx";
        Connection connection = DriverManager.getConnection(url, username, password);
        String sql = "insert into user(id, name, age) values(10, '张三', 100)";
        Statement statement = connection.createStatement();
        statement.executeUpdate(sql);
        statement.close();
		connection.close();
    }
}
```

#### PreparedStatement

Statement的子类，提供了SQL占位符的功能。

- 使用Statement开发问题
  - 需要频繁拼接String字符串，出错率高
  - 存在SQL注入风险

```java
Connection connection = DriverManager.getConnection(url, username, password);
String sql = "select * from user where username = ? and password = ?";
PreparedStatement preparedStatement = connection.prepareStatement(sql);
preparedStatement.setString(1, "zyuanlee");
preparedStatement.setString(2, "123456");
ResultSet resultSet = preparedStatement.executeQuery();
System.out.println(resultSet);
resultSet.close();
preparedStatement.close();
connection.close();
```

## 08-数据库连接池

JDBC开发流程

- 加载驱动（只需加载一次）
- 建立数据库连接（Connection）
- 执行SQL（Statement）
- ResultSet接受结果集（查询）
- 断开连接，释放资源

数据库连接对象是通过DriverManager来获取的，每次都需要向数据库申请获取连接，验证用户名和密码，执行完SQL语句后断开连接，这样会造成资源浪费，使用数据库连接池解决。

数据库连接池的基本思想是为数据库建立一个缓冲池，预先向缓冲池中放入一定数量的连接对象，当需要获取数据库连接的时候，只需要从缓冲池中取出一个对象，用完之后再放回缓冲池中，供下一次请求使用。

当数据库连接池中没有空闲连接时，新的请求就会进入等待队列，等待其他线程释放资源。

### 数据库连接池实现

javax.sql.DataSource，可以不自己实现该接口，使用第三方工具。

## 09-DBUtils

完成数据封装（结果集到java对象的映射）

```java
String sql = "select * from student where id = 30";
QueryRunner queryRunner = new QueryRunner();
student = queryRunner.query(connection, sql, new BeanHanler<>(Student.class));

String sql = "select * from student where id = ?";
QueryRunner queryRunner = new QueryRunner();
student = queryRunner.query(connection, sql, new BeanHanler<>(Student.class), id);
```

ResultHandler接口用来处理结果集，可以将查询到的结果转为java对象，提供了4钟实现类

- BeanHandler：将结果集映射为java对象（单条数据）
- BeanListHandler：映射为List集合（多条数据）
- MapHandler：映射为Map对象
- MapListHandler：映射为MapList集合