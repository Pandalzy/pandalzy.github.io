---
title: 计算机程序设计语言原理概念重点
date: 2019-12-28 20:28:19
tags: ["期末复习", "程序设计语言原理"]
categories: ["课程学习"]
---

## 第一章——基本概念

### 语言的评价标准

-   可读性
-   可写性
-   可靠性
-   代价

### 可读性中正交性

-   使用该语言中**一组相对少量**的基本结构，经过少量的结合步骤，就可以构成该语言的**控制结构和数据结构**，而且它的基本结构的任何组合都是合法和有意义的。

### 语言的分类

-   命令式语言
-   函数式语言
-   逻辑语言
-   面向对象语言

### 影响语言设计的因素

-   计算机体系结构
-   程序设计方法学

## 第二章——发展史

-   第一个高级语言：Fortran
-   第一个具有结构化和接口化的语言：Algol 60
-   第一个面向对象的语言：SIMULA 67
-   美国国防部耗资巨大创建的语言：Ada
-   第一个纯面向对象的语言：Smalltalk
-   两个早期的动态语言：APL、SNOBOL

## 第五章——名字、绑定等

### 关键字、保留字与预定义名字

-   关键字
    -   在特定的上下文中是特殊的
    -   （Fortran 中，`real a`是声明语句，`a = 3.4`是赋值语句）
    -   缺点：可读性差
-   保留字
    -   一个特殊的字，不能作为用户自定义名字
-   预定义名字
    -   介于关键字与保留字
    -   有预定义的意义，但是能被用户重新定义

### 变量

-   是抽象的内存单元
-   **有六个属性：名字、地址、值、类型、生命周期与范围**（匿名的无名字）

### 别名（aliases）

-   如果两个变量名字能访问同一内存地址，他们就被叫做别名
-   缺点

    -   可读性差
    -   可靠性差

-   别名如何被创造
    -   指针、引用变量、C 和 C ++联合
    -   别名的某些原始理由不再有效
    -   用动态分配替换它们

### 左值、右值

-   左值

    -   变量的内存地址

-   右值
    -   变量的值

### 类型

-   决定变量值的范围
-   根据类型为变量设定操作集合
-   在浮点指针中，类型也决定精确度

### 抽象内存单元

-   单元格具有与其关联的变量所需的大小

### 绑定

-   是一种关联（属性和实体、操作和符号）
-   **静态绑定**
    -   它首次发生在运行前，并且整个程序运行过程中保持不变
-   **动态绑定**
    -   它首次放生在运行时，或者在程序执行过程中可以改变
-   显式声明
    -   一个被用作声明变量类型的说明语句
-   隐式声明
    -   一个默认的机制，用来指明变量的类型

### 存储绑定与生命周期

-   **静态变量**

    -   在程序执行前绑定在存储单元，在整个执行过程中都绑定在同一存储单元的变量
    -   **优点**
        -   高效、历史敏感
    -   **缺点**
        -   不灵活

-   **栈动态变量**
    -   当确立他们的声明语句时即产生了存储绑定，但它们的类型时静态绑定的变量
    -   当子程序开始执行之时，才绑定到存储空间，并且执行终止时才解除这种绑定的变量
-   **生命周期**
    -   该变量被绑定于某一特定存储地址的时间

### 类型检测

-   是保证一个操作符的所有操作数都具有相互兼容类型的措施

    -   兼容类型时对操作符而言为合法的类型，或者在语言规定的允许下，能够被编译器隐式转换为合法类型

-   **类型错误**
    -   是将操作符作用于具有不适当类型的操作数
    -   如果在一种语言中，所有变量类型的绑定都是静态的，那么几乎总是能够静态地进行类型检测
    -   动态类型的绑定要求在运行时进行类型检测，这种类型检测被称为**动态类型检测**

### 类型强化

-   只要某个程序设计语言总能够发现其程序中的类型错误，就定义这种程序设计语言为强类型的
-   **优点**
    -   能够发现所有因为变量的误用而导致的类型错误

## 第六章——数据类型

### 悬挂指针

-   是一个包含了已解除分配的堆动态变量地址的指针

-   **危害**

    -   悬挂指针指向的位置可能已经被重新分配给一个新的动态变量，新堆动态变量的值就会被破坏，存储管理的失败

-   产生
    -   设指针 p1 指向一个新的堆动态变量
    -   给指针 p2 赋以 p1 的值
    -   将 p1 所指向的堆动态变量显式回收，并将 p1 变为 null，但是这种操作并不改变 p2，p2 现在成为一个悬挂指针。如果回收操作不改变 p1，p1 和 p2 都将是悬挂的

## 第七章——表达式与赋值语句

### 操作符重载

-   一个操作符的多种用途

-   危害
    -   影响可读性
    -   有些问题编译器无法检测，如`x = a(a漏写) & b`

## 第九章——子程序

-   一种程序设计语言可以包括两种基本的抽象设施
    -   过程抽象
    -   数据抽象

### 通用子程序特点（General subprogram characteristics）

-   每一个子程序都有一个入口
-   在被调用的子程序执行期间，调用程序单元被停止执行，这意味着在任何给定时刻，只有一个子程序在执行
-   在子程序的结束时，总是将控制返回到调用程序

### 基本定义

-   **参数描述（profile）**

    -   它所具有的形参数目、次序以及类型

-   **协议**

    -   参数描述加上它的返回类型，如果它是函数

-   **原型**
    -   子程序的声明

### 参数

**形参：**子程序首部中的参数

**实参：**一组将与子程序中的形参相绑定的参数

**位置参数：**形参与实参的绑定是通过简单的位置进行的

**关键字参数：**将一个与实参相绑定的形参的名称与这个实参在一起被声明，如`post(url=post_url,data=post_data)` 缺点：使用人员必须知道形参的名字

### 局部变量

-   定义于子程序内部的变量

#### 栈动态

-   优

    -   为子程序提供了灵活性
    -   与局部变量的存储空间可共享

-   缺
    -   在存储空间分配、初始化、变量解除分配有时间花费
    -   栈动态局部变量的存取必须是间接的
    -   不是历史敏感的

#### 静态

-   优

    -   高效，直接存取局部变量
    -   分配与解除分配没有额外的时间代价
    -   具有历史敏感敏感性

-   缺
    -   不灵活，不支持递归运算
    -   存储空间不能与局部变量共享

### 参数传递方法

-   按值传递
-   按结果传递
-   按值-结果传递
-   按引用传递
-   按名传递

### 重载子程序

-   是与另一个在相同引用环境中的子程序具有相同名称的子程序
-   它必须与子程序的其他版本在参数的数目、顺序、类型不相同
-   如果是一个函数，则是返回的类型不同

### 分别编译

-   编译单元能在不同时间被编译，但是如果访问或使用其他实体，则编译不是独立的
-   为了提供分别编译的可靠性，编译器必须访问程序单元用到的，但是在别处声明的实体
-   通过独立编译，程序单元能在不知道其他程序单元的情况下被编译
-   最大特点
    -   在分别编译单元之间的接口不进行类型一致检查

### 非局部、全局变量

-   局部变量
    -   在子程序中可见，但不是局部声明的
-   全局变量
    -   在程序单元中都可见的变量

## 第十章——实现子程序

### 子程序链接

-   子程序的调用及返回操作的统称

### 子程序调用过程

1. 如果局部变量是非静态的，它必须对局部变量进行存储空间分配，还要将这些变量与存储空间绑定
2. 必须保留调用程序单元的执行状态
3. 将控制转移到子程序的代码，并且在子程序结束后能保证将控制返回正确位置
4. 提供对被调用子程序为可见的非局部变量的访问

### 子程序的返回过程

1. 将形参的局部值转移到相关联的实参上
2. 解除分配局部变量占有的存储空间，并恢复调用程序的执行状态
3. 将非局部引用的机制返回到调用之前的状态
4. 必须将控制返回到调用程序

## 第十一章——抽象与封装

### 基本抽象类型

-   过程抽象
-   数据抽象

### 封装

-   将子程序与它们所用的数据组合
-   好处
    -   解决模块化问题
    -   解决重新编译问题

### 抽象数据类型（封装）

-   仅包含一种特定数据类型的数据表示形式，以及提供该类型操作的子程序
-   优点
    -   对抗复杂性的武器
    -   一种使大型和/或复杂程序更易于管理的方法
-   示例
    -   Ada 封装结构为——包
    -   C++——类和结构
    -   Java——类

## 第十三章——并发

### 并发种类

-   物理并发
    -   有着多个处理器可供使用，并且来自相同程序的几个程序单位同时地运行
-   逻辑并发
    -   程序是在一个处理器上被分时地执行

### 准并发

-   具有协同（coroutines）的程序

### 控制线（Thread of control）

-   控制流经过程序时到达程序点的序列

### 同步

-   合作同步
    -   当任务 A 在继续它的执行之前，它必须等待任务 B 完成某种特定活动
-   竞争同步
    -   当两个任务都需要不可能同时使用的某种资源

### 信号量

-   一种能够用来提供任务同步的简单机制
    -   一种数据结构
    -   由一个整数和一个存储任务描述符的队列组成

### 会合（rendezvous）

-   如果任务 A 需要发送一个消息给任务 B，并且任务 B 愿意接收，消息就能够被传递过来
    -   会合只会发生在发送者和接收者都希望它发生的时候

## 第十四章——异常处理

### 异常分类

-   继续模型
-   终止模型
-   重试模型

### 比较 Ada、java 与 C++异常处理异同点

-   结构上
    -   Ada 采用**EBNF**的形式：`when 异常选择{|异常选择}=>语句序列`
    -   C++采用**try-catch**块
    -   Java 采用**try-catch**块与**finally**语句
-   引发语句
    -   Ada 采用**raise[异常名]**
    -   C++和 Java 采用**throw[表达式]**
-   传播方式
    -   Ada 中逐步向调用者上层去寻找，如果没有找到就自动结束
    -   C++和 Java 中也是逐步向调用者上层去寻找，没找到就用默认处理方式
-   匹配方式
    -   Ada 采用字符串匹配，属于类型匹配
    -   C++和 Java 中除了类型匹配外，还进行最先匹配和最佳匹配方式
