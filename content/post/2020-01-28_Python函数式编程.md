---
title: Python函数式编程
date: 2020-01-28 15:46:05
tags: [Python3]
categories:
---

## 高阶函数

### map/reduce

-   `map()`
    -   `map()`函数接收两个参数，一个是函数，一个是`Iterable`，`map`将**传入的函数依次作用到序列的每个元素**，并把结果作为新的`Iterator`返回

```python
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

<!-- more -->

-   `reduce()`
    -   `reduce`把一个函数作用在一个序列`[x1, x2, x3, ...]`上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算，其效果就是
    -   `reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)`

```python
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
```

-   把序列`[1, 3, 5, 7, 9]`变换成整数`13579`

```python
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```

#### filter

-   `filter()`函数用于过滤序列
-   `filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素
-   在一个 list 中，删掉偶数，只保留奇数

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

-   把一个序列中的空字符串删掉

```python
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```

#### sorted

```python
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
```

-   `sorted()`函数也是一个高阶函数，它还可以接收一个`key`函数来实现自定义的排序，例如按绝对值大小排序

```python
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```

-   字符串排序

```python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
```

> 默认情况下，对字符串排序，是按照 ASCII 从小到大排序

-   给`sorted`传入 key 函数，即可实现忽略大小写的排序

```python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
```

-   要进行反向排序，不必改动 key 函数，可以传入第三个参数`reverse=True`

```python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```

## 返回函数

### 函数作为返回值

-   高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回

-   如果不需要立刻求和，而是在后面的代码中，根据需要再计算

```python
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
```

-   当调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数

```python
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
```

-   调用函数`f`时，才真正计算求和的结果

```python
>>> f()
25
```

### 闭包

```python
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
```

-   在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的 3 个函数都返回了
-   可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果是

```python
>>> f1()
9
>>> f2()
9
>>> f3()
9
```

-   全部都是`9`！原因就在于返回的函数引用了变量`i`，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量`i`已经变成了`3`，因此最终结果为`9`

> 返回函数不要引用任何循环变量，或者后续会发生变化的变量

-   如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变

```python
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
```

```python
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
```

## 匿名函数

```python
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

-   匿名函数`lambda x: x * x`实际上就是

```python
def f(x):
    return x * x
```

-   关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数
-   匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果
-   用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数

```python
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

-   也可以把匿名函数作为返回值返回

```python
def build(x, y):
    return lambda: x * x + y * y
```

## 装饰器

-   由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数

```python
>>> def now():
...     print('2015-3-25')
...
>>> f = now
>>> f()
2015-3-25
```

-   函数对象有一个`__name__`属性，可以拿到函数的名字

```python
>>> now.__name__
'now'
>>> f.__name__
'now'
```

-   现在，假设要增强`now()`函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改`now()`函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）
-   本质上，decorator 就是一个返回函数的高阶函数。所以，要定义一个能打印日志的 decorator，可以定义如下

```python
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

-   观察上面的`log`，因为它是一个 decorator，所以接受一个函数作为参数，并返回一个函数。要借助 Python 的**@语法**，把 decorator 置于函数的定义处

```python
@log
def now():
    print('2015-3-25')
```

-   调用`now()`函数，不仅会运行`now()`函数本身，还会在运行`now()`函数前打印一行日志

```python
>>> now()
call now():
2015-3-25
```

-   把`@log`放到`now()`函数的定义处，相当于执行了语句`now = log(now)`
-   由于`log()`是一个 decorator，返回一个函数，所以，原来的`now()`函数仍然存在，只是现在同名的`now`变量指向了新的函数，于是调用`now()`将执行新函数，即在`log()`函数中返回的`wrapper()`函数
-   `wrapper()`函数的参数定义是`(*args, **kw)`，因此，`wrapper()`函数可以接受任意参数的调用。在`wrapper()`函数内，首先打印日志，再紧接着调用原始函数
-   如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数，写出来会更复杂。比如，要自定义 log 的文本

```python
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
        	print('%s %s():' % (text, func.__name__))
        	return func(*args, **kw)
    	return wrapper
    return decorator
```

-   这个 3 层嵌套的 decorator 用法如下

```python
@log('execute')
def now():
    print('2015-3-25')
```

-   执行结果如下

```python
>>> now()
execute now():
2015-3-25
```

-   3 层嵌套的效果`now = log('execute')(now)`

-   首先执行`log('execute')`，返回的是`decorator`函数，再调用返回的函数，参数是`now`函数，返回值最终是`wrapper`函数
-   但经过 decorator 装饰之后的函数，它们的`__name__`已经从原来的`'now'`变成了`'wrapper'`

```python
>>> now.__name__
'wrapper'
```

-   因为返回的那个`wrapper()`函数名字就是`'wrapper'`，所以，需要把原始函数的`__name__`等属性复制到`wrapper()`函数中，否则，有些依赖函数签名的代码执行就会出错
-   Python 内置的`functools.wraps`可以进行此操作

-   一个完整的 decorator 的写法如下

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

-   针对带参数的 decorator

```python
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

## 偏函数

```python
>>> int('12345')
12345
# 如果传入base参数，就可以做N进制的转换
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565
```

```python
def int2(x, base=2):
    return int(x, base)
```

-   `functools.partial`就是帮助创建一个偏函数的，不需要自己定义`int2()`，可以直接使用下面的代码创建一个新的函数`int2`

```python
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
```

-   所以，简单总结`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单
-   注意到上面的新的`int2`函数，仅仅是把`base`参数重新设定默认值为`2`，但也可以在函数调用时传入其他值

```python
>>> int2('1000000', base=10)
1000000
```

-   最后，创建偏函数时，实际上可以接收函数对象、`*args`和`**kw`这 3 个参数，当传入：

```python
int2 = functools.partial(int, base=2)
```

-   实际上固定了 int()函数的关键字参数`base`，也就是：

```python
int2('10010')
# 相当于
kw = { 'base': 2 }
int('10010', **kw)
```

-   当传入：

```python
max2 = functools.partial(max, 10)
```

-   实际上会把`10`作为`*args`的一部分自动加到左边，也就是：

```python
max2(5, 6, 7)
# 相当于
args = (10, 5, 6, 7)
max(*args)
# 10
```
