---
title: 面向对象知识点
date: 2020-06-21 20:00:28
tags: [期末学习, 面向对象]
categories: [课程学习]
---

## 1-3 章

### 应用 UML 的三种方式

-   UML 作为草图
    -   白板上手绘非正式、不完整的图
    -   用于探讨问题或解决方案的复杂部分
-   UML 作为蓝图
    -   逆向工程，以 UML 图的方式对现有代码进行可视化，使其易于理解。
    -   代码生成，一般用其生成部分代码，开发人员填充其他代码
-   UML 作为编程语言
    -   用 UML 完成软件系统可执行规格说明
    -   可执行代码自动生成

### 应用 UML 的三种透视图

-   概念透视图
    -   用图来描述现实世界或者关注领域中的事务
-   规格说明（软件）透视图
    -   用图来描述软件的抽象物或具有规格说明和接口的构件，但是并不约定特定实现
-   实现（软件）透视图
    -   用图来描述特定技术中（如 java）的软件实现

### 不同视图中类的含义

-   概念类：现实世界中的概念或事物
-   软件类：无论在过程还是方法中，都表示软件构件在规格说明或实现透视图中的类
-   实现类：特定 OO 语言中的类

### 统一过程特点

-   用例驱动
-   以架构为中心
-   迭代和增量

### 如何在迭代项目中处理变更

-   一方面认同和稳定一组需求，另一方面接受需求不断变更的事实
-   每次迭代选择一小组需求，快速设计、实现和测试
-   早期迭代可能并不准确，但是快速实施可以得到快速反馈
-   早期迭代中系统偏离正确轨迹的程度会大于后继迭代。随着时间的发展，系统将会收敛。
-   最好及早解决和验证具有风险的、关键的设计决策

### 早期迭代与后期迭代

-   早期迭代远离系统的“真实路径”。通过反馈和调整，系统向最适宜的需求和设计收敛。
-   在后期迭代中，很少会在需求上产生显著变化，这种后期的变化可能会给组织带来业务竞争优势。

### 迭代开发优点

-   减少项目失败可能性，提高生产率，降低缺陷率
-   在早期缓解高风险
-   早期可见进展
-   早期反馈、用户参与和调整，会产生更接近涉众真实需求的精华系统
-   可控复杂性，团队不会被“分析瘫痪”或长期且复杂的步骤所淹没
-   一次迭代中的经验可以被系统地用于改进开发过程本身，并如此反复进行下去

### 一次迭代的持续时间和时间定量

-   大部分迭代方法建议迭代时间在 2 周之内。小步骤、快速反馈和调整是迭代开发的主要思想，时间过长会增加风险。
-   1 周的迭代不足以获得有意义的产出和反馈，大于 6 周，复杂性会变得不可控制，反馈将延迟。
-   迭代的一个关键思想是时间定量或时长固定。约定了时间，必须按时完成，实在完不成，不能推迟时间，而是剔除一些任务或需求。

### UP 核心思想

-   短时间定量迭代、进化和可适应性开发

### UP 的四个阶段

-   初始（Inception）：大体上的构想、业务案例、范围和模糊评估——可行性研究。
-   细化（Elaboration）：已精化的构想、 核心架构的迭代实现、 高风险的解决、 确定大多数需求和范围以及进行更为实际的评估。
-   构造(Construction)：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署 。
-   移交(Transition)：进行 beta 测试和部署。

## 4-7 章

### 初始阶段内容

-   10％的用例进行分析；
-   关键的非功能需求的分析；
-   业务案例创建；
-   开发环境的准备

### 初始阶段需要回答问题

-   该项目的 vision（设想/愿景） 和 business case（业务案例） ?
-   是否可行?
-   购买还是开发
-   成本的大致估计; 是\$10K，100K，1000K?
-   项目继续还是停止?

### 初始阶段制品

-   设想和业务用例（Vision and Business Case）
    -   描述高阶目标与约束、业务案例，并提供执行摘要
-   用例模型（Use-Case Model）
    -   描述功能需求。在初始阶段，确定大部分用例名称，详细分析 10%的用例
-   补充性规格说明（Supplementary Specification）
    -   描述其他需求，主要是非功能性需求。初始阶段，多考虑关键的非功能性需求，其对架构将会产生主要影响
-   词汇表（Glossary）
    -   关键领域术语和数据字典
-   风险列表和风险管理计划（Risk List&Risk Management Plan）
    -   描述风险（业务、技术、资源和进度）及应对和缓解的方法
-   原型和概念验证（Prototypes and Proof-of-concepts）
    -   澄清设想，验证技术思路。
-   迭代计划（Iteration Plan）
    -   描述第一个细化迭代的任务。
-   阶段计划和软件开发计划（Phase Plan & Software Development Plan）
    -   对细化阶段的持续时间和工作量进行粗略估计。工具、人员、教育和其他资源。
-   开发案例（Development Case）
    -   就待定项目，对 UP 步骤和制品进行定制的描述。在 UP 中，通常会为特定项目进行定制。

### 需求——涉众

-   涉众是与要建设的业务系统相关的一切人和事。
-   涉众是所有会受到项目结果重大影响的人，必须用所提供的解决方案来满足不同的需要。
-   许多涉众都是系统的用户（间接或者直接），还有系统的经济型买主或支持者。
-   了解涉众的组成及其特定需要是开发有效解决方案的关键。

### 需求的类型和种类

-   功能性（Functionality）：特性、功能、安全性。
-   可用性（Usability）：人性化因素、帮助、文档。
-   可靠性（Reliability ）：故障频率、可恢复性、可预测性。
-   性能（Performance ）：响应时间、吞吐量、准确性、有效性、资源利用率。
-   可支持性（Supportability）：适应性、可维护性、国际化、可配置性
-   FURPS+中的“+” 号意味着还有一些其他的约束，如:
    -   实现（Implementation）：资源限制、语言和工具、硬件等。
    -   接口（Interface）：强加于外部系统接口之上的约束。
    -   操作（Operation）：对其操作设置的系统管理。
    -   包装（Packaging)：例如物理的包装盒。
    -   授权（Legal）：许可证或其它方式。

### UP 制品如何组织需求——关键的 UP 需求制品

-   用例模型
    -   一组使用系统的典型场景。主要用于功能（行为的）需求。
-   补充规格说明
    -   基本上是用例之外的所有内容。主要用于所有非功能需求，例如性能或许可发布。 该制品也用来记录没有表示(或不能表示）为用例的功能特性，例如报表生成。
-   词汇表
    -   定义重要的术语，数据字典记录了关于数据的需求，例如有效性规则，容许值等。对象属性、操作调用的参数、报表布局等。
-   设想
    -   概括了高阶需求，这些需求在用例模型和补充性规格说明中进行细化。设想也概括了项目的业务案例。设想是简短的执行概要文档 ，用以快速了解项目的主要思想。
-   业务规则
    -   领域规则，描述了凌驾于某一软件项目的需求或政策，这些规则是领域或业务所要求的，并且许多应用应该遵从这些规则。例如政府的税收法规。
    -   领域规则的细节可以记录在补充性规格说明中，因为这些规则通常更为持久，对不止一个软件项目适用，应将其放入集中的业务规则制品，以便重用。

### 用例的好处

-   从用户的角度获取操作性需求。
-   对系统的功能进行清晰而一致的描述。
-   系统测试的基础。
-   提供了从功能需求跟踪到系统中真正的类和操作的能力。

### 为什么使用用例

-   使工作保持简单的好方法。
-   使领域专家或需求提供者自己编写（或参与编写）用例成为可能。
-   强调了用户的目标和观点。
-   更强调以客户为中心。
-   能够根据需要对复杂程度和形式化程度进行增减删节。

### 参与者的三种类型

-   主要参与者：具有用户目标，并通过使用 SuD 的服务完成。
    -   为何确定主要参与者？用来发现驱动用例的用户目标
-   协助参与者：为 SuD 提供服务，通常是计算机系统，但也可以是组织或人。
    -   为何确定协助参与者？为了明确外部接口或利益
-   幕后参与者：在用例行为中具有影响或利益，但不是主要或协助参与者。例如，政府收税机构。
    -   如何要确定幕后参与者？是为了确保确定并满足所有必要的重要事物。如果不明确地对幕后参与者进行命名，则有时很容易忽略其影响或利益。

### 用例的三种常用形式

-   摘要：简洁的一段式概要，通常用于主成功场景。
    -   何时使用？在早期需求分析过程中，为快速了解主体和范围使用。可能只需要几分钟编写
-   非正式：非正式的段落格式。用几个段落覆盖不同场景。
    -   何时使用？同上
-   详述：详细编写所有步骤及各种变化，同时具有补充部分，如前置条件和成功保证
    -   何时使用？确定并以摘要形式编写了大量用例后，在第一次需求讨论会中，详细地编写其中少量的具有重要架构和高价值的用例

### 详述用例模版

-   用例名称：以动词开始
-   范围：界定了所要设计的系统
-   级别：用户目标级别或子功能级别（重用，如信用卡支付）。
-   主要参与者：调用系统，使之交付服务
-   涉众及其关注点列表：关注该用例的人及其需要。重要！能够让我们更清楚详细的系统职责
-   前置条件：值得告知读者的，开始前必须为真的条件
-   成功保证：值得告知读者的，成功完成必须满足的条件
-   主成功场景：典型的、无条件的、理想方式的成功场景
-   扩展：成功或失败的替代场景
-   特殊需求：相关的非功能需求
-   技术和数据变元表：不同的 I/O 方法和数据格式
-   发生频率：影响对实现的调查、测试和时间安排
-   杂项：例如未解决问题

### 准则：以无用户界面的本质风格编写用例

-   收银员会说“登录”。
-   收银员想到的图形界面、对话框、用户名、密码。
-   这是实现的一种机制，而不是目标本身。
-   与实现机制无关的目标：“标识自己的身份并得到认证”。
-   或更高层次的目标：“防盗”。

### 以本质风格编写用例

-   本质风格编写用例，摒除用户界面并且关注参与者的意图。
-   具体风格用例文本涵盖对用户界面的决策，在早期需求工作中应该避免。

### 编写黑盒用例

编写黑盒用例，不对系统内部工作、构件或设计进行描述，通过职责描述系统。

### 如何发现用例

-   选择系统边界，系统仅仅是软件应用，还是将硬件和作用作为整体，是一个人使用，还是整个组织使用。
-   寻找主要参与者，通过使用系统的服务实现目标的人或事。
-   确定每个参与者的目标
-   定义满足用户目标的用例，根据其目标对用例命名。通常，用户目标级别的用例和用户目标是一一对应的

### 什么样的问题有助于寻找参与者和目标

-   谁来启动和停止系统。
-   谁来完成用户管理和安全管理。
-   谁来完成系统管理。
-   “时间”是管理者吗。因为系统要响应时间事件而完成某些活动。
-   系统失败时，是否存在监控进程将系统重新启动。
-   软件升级是如何处理的，是推模式还是拉模式。
-   除了人作为主要参与者外，还有其他外部的软件或自动机器系统调用该系统的服务吗。
-   谁来考察系统活动或性能。
-   谁来考察日志，是否可以远程检索。
-   系统发生错误或故障时应通知谁

### 用例的粒度问题

-   大用例
    -   我们的企业需要拓宽销售渠道。
    -   整个系统就只有一个用例!!!
-   小的用例
    -   输入口令。
    -   系统中可能有成百上千个用例!!!
-   我们必须权衡

### 什么样的测试有助于发现有用的用例

-   老板测试
-   EBP 测试
-   规模测试

### 补充性规格说明中的元素

-   FURPS+ 需求-功能性、可用性、可靠性和可支持性。
-   报表。
-   硬件和软件约束。
-   领域 (或者业务) 规则。
-   法律问题 – 责任，知识产权，等等。
-   包装, 等等。

### Vision (设想/愿景）元素

-   修订历史
-   定位
-   涉众描述
-   产品概述
-   系统特性概要
-   其他需求和约束

### 是否应该在设想文档中重复其他需求

-   设想文档中，系统特性简明概括了通常在用例中要详细说明的功能性需求。
-   设想文档能对补充性规格说明中详细说明的其他需求（如可靠性和可用性）加以概括。
-   尽量避免陷入对自己的重复当中。
-   对于其他需求，需避免在设想和补充性规格说明中重复或近于重复。最好在补充性规格说明中记录这些需求，设想中，加以指引

### 先写设想还是用例

建议如下顺序

-   首先编写简要的设想草案。
-   确定用户目标和对应的用例名称。
-   详细编写一些用例，并且开始编写补充性规格说明。
-   精化设想，对以上制品信息进行概括。

## 8-9 章

### 细化阶段开始构建的制品

-   领域模型
    -   概念模型的可视化，类似于领域实体的静态信息模型。
-   设计模型
    -   描述逻辑设计的一组图，包括软件类图、对象交互图、包图等。
-   软件架构文档
    -   学习辅助工具，概括关键架构问题及其在设计中的解决方案。该文档是对重要设计思想及其在系统中动机的概要。
-   数据模型
    -   包括数据库方案，以及在对象和非对象表示之间映射的策略。
-   用例示意板，用户界面原型
    -   描述用户界面、导航路径、可用性模型等。

### 领域模型并非表示软件制品或类

领域模型是对所关注的现实世界领域中事物的可视化，而不是诸如 java 或 C#类的软件对象，或有职责软件对象

### 领域模型和数据模型是一回事吗

-   领域模型不是数据模型。
-   不会排除需求中没有明确要求记录其相关信息的类。
-   不会排除没有属性的概念类。

### 为什么要创建领域模型

-   它是一种可视化语言，传达了真实世界中的概念或者该领域中的概念类。
-   在 UP 领域模型中，涉众对领域内重要概念的看法——影响设计者，降低差异。
-   降低与 OO 建模之间的表示差异
    -   领域层软件类的名称要源于领域模型中的名称，减少我们的思维与软件模型之间的表示差异

### 如何创建领域模型

以当前迭代中所要设计的需求为界

1. 寻找概念类。
2. 将其绘制为 UML 类图中的类。
3. 添加关联和属性

### 如何找到概念类（扩充）

1. 重用和修改现有的模型。
2. 使用分类列表。
3. 确定名词短语

### 报表对象——模型中是否要包括“票据”

-   一般来说，在领域模型中显示其它信息的报表并没有意义，因为其所有信息都是源于或者复制于其它信息源的。
-   另外一方面，就业务规则而言，收据又有特殊的作用，在我们退货时，我们需要收据作为凭据

### 为什么需要描述类

-   Item 实例表示商店里实际的商品，他可以拥有一个序列号。
-   Item 具有描述、价格和 ID，这些内容不会在任何其他地方记录。
-   商店里每个工作人员都有健忘症。
-   每售出一件实际的商品，相应的 Item

### 何时使用“描述”类建模

-   需要有关商品或服务的描述，独立于任何商品或服务的现有实例。
-   删除其所描述事务（如 Item）的实例后，导致信息丢失，而这些信息是需要维护的，但是被错误地与所删除的事务关联起来。
-   减少冗余或重复信息

### 何时添加关联

-   如果存在需要保持一段时间的关系，将这种语义表示为关联（“需要记住”的关联）。
-   可以从常见关联列表中派生的关联

### 准则：避免加入大量关联

-   如果我们有 n 个类，将会有 n(n-1)个关联。
-   “视觉干扰”，使图变得混乱。
-   关注“需要记住”的关联。

### 关联是否会在软件中实现

-   关联不是数据流、数据库外键联系、实例变量或软件方案中的对象连接的语句；
-   关联声明的是针对现实领域从纯概念角度看有意义的关系。
-   添加关联是为了突出我们对重要关系的大致理解，而非记录对象或数据的结构

### 何时定义新的数据类型类

在下述情况下，在领域模型里，把最初被认为是数字或字符串的数据类型表示为新的数据类型类：

-   由不同的小节组成（如电话号码、人名、地址）
-   具有与之相关的操作，例如解析或校验（如社会安全号）
-   具有其他属性（如促销价格有开始日期和结束日期）
-   单位的数量（如支付总额具有货币单位）
-   具有以上性质的一个或多个类型的抽象（如商品标识符）

## 10-16 章

### 什么是系统顺序图

-   系统顺序图（SSD）
    -   是为阐述与所讨论系统相关的输入和输出事件而快速、简单地创建的制品。
    -   它展示了对一个特定的用例，直接与系统交互的外部参与者、系统（作为黑盒）以及由参与者发起的系统事件。
    -   用例文本暗示了 enteritem 事件，SSD 将其变得具体明确。
-   **准则：**应为每个用例的主成功场景，以及频繁发生的或者复杂的替代场景绘制 SSD

### 为什么绘制 SSD

软件设计的问题：系统会发生什么事件，必须为处理和响应这些事件（来自于鼠标、键盘、其他系统）来设计软件。因此，必须准确地知道，什么事外部输入的事件，即系统事件。这些事件是系统行为分析的重要部分。

软件系统要对以下三种事件进行响应：

1. 来自于参与者（人或计算机）的外部事件
2. 时间事件。
3. 错误或异常（通常源于外部）

### 契约有哪些部分

-   操作
    -   操作的名称和参数
-   交叉引用
    -   会发生此操作的用例
-   前置条件
    -   执行操作之前，对系统或领域模型对象状态的重要假设。这些假设比较重要，应该告诉读者。
-   后置条件
    -   最重要的部分，完成操作之后，领域模型对象的状态。

### 后置条件描述了领域模型中对象状态的变化

-   实例创建和删除。
-   属性值的变化。
-   关联形成和消除

### 如何创建和编写契约

#### 创建契约

-   从 SSD 中识别系统操作
-   如果系统操作复杂，其结果可能不明显，或者在用例中表达不清楚的系统操作，构造一个契约
-   为了描述后置条件，使用下列列表
    -   实例创建或删除
    -   属性修改
    -   关联形成和清除

#### 编写契约

-   以说明性的、被动式的过去时态编写后置条件
-   要在已有的或新创建的对象之间建立关联

### 使用层有助于解决以下问题

-   源代码的变更波及整个系统——大部分系统是高度耦合。
-   应用逻辑与用户界面交织在一起，因此，无法复用于其他不同界面或分布到其他处理节点之上。
-   潜在的一般性技术服务或业务逻辑与更特定于应用的逻辑交织在一起，因此无法被复用、分布到其他节点或方便的使用不同实现替换。
-   不同的关注领域之间高度耦合。因此，难以为不同开发者清晰地界定和分配任务

### 使用层的好处

-   总的来说，使用层可以做到关系分离、高级服务与低级服务分离、特定于应用的服务与一般性服务分离；

-   层可以减少耦合和依赖性、增强内聚性、提高潜在的复用性并且使概念更加清晰。
-   封装和分解了相关的复杂性。
-   某些层能够用新的实现替换。对于较低级的技术服务层来说不大可能（如，java.util），但对于 UI、应用层和领域层来说是可能的。
-   较低层包含可复用功能。
-   某些层（主要是领域层和技术服务层）可以是分布式的。
-   通过逻辑划分，有助于团队开发。

### 观察者模式（选择）

观察者模式（Observer）是对该原则的合理扩充，即领域对象只能通过 PropertyListener(Java 中的常用接口)的接口向视图的 UI 对象发送消息。

### 模型-视图分离的动机包括

-   支持内聚的模型定义，这些定义只关注领域过程，而不是用户界面。
-   允许对模型和用户界面层分别进行开发。
-   使界面的需求变更对领域层的影响最小化。
-   允许新视图能方便地连接到现有的领域层之上，而不会对领域层产生影响。
-   允许对同一模型对象同时使用多个视图，例如，销售信息同时具有表格和业务图表视图。
-   允许模型层的运行不依赖于用户界面层。例如，消息处理后批处理模式的系统。
-   允许简模型层能方便地移植到另一用户接口框架下

### 创始消息

-   最开始的消息在 UML 称为创始消息（Found Message），以实心圆作为起点表示此类消息
-   创始消息表示没有特定发送者、发送者不明确或消息源众多的消息。

### 组合优于聚合

-   聚合(aggregation)
    -   一种模糊的关联，其不精确地暗示了整体-部分关系。
    -   准则：不要在 UML
-   组合(composition)
    -   组合关系有几个含义
        -   在某一时刻，部分的实例（如：Square）只属于一个组成实例(如：Board)
        -   部分必须总是属于组成（不存在随意游离的 Fingers）。
        -   组成要负责创建和删除其部分，既可以自己来创建/删除部分，也可以与其他对象协作来创建/删除部分
    -   如果组成被销毁，其部分也必须被销毁

### 主动类

-   主动对象（active object）运行于自己控制的执行线程之上。
-   主动对象的类即为主动类(active class)

## 17-21 章

### 职责和职责驱动设计

-   对象的行为职责
    -   自身执行一些行为，例如创建对象或计算。
    -   初始化其他对象中的动作。
    -   控制或者协调其它对象的活动。
-   对象的认知职责
    -   对私有封装数据的认知。
    -   对相关对象的认知。
    -   对其能够导出或计算的事物的认知

### 设计模式的基本要素

-   设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，
-   其中的关键元素包括以下**四个方面**：
    -   模式名称 (Pattern name)
    -   问题 (Problem)
    -   解决方案 (Solution)
    -   效果 (Consequences)

### 坏味代码(Code Smell）特点

-   冗余的代码。
-   大型方法。
-   具有大量实例变量的类。
-   具有大量代码的类。
-   明显相似的子类。
-   在设计中很少使用或者没有使用接口。
-   许多对象之间有很多的耦合度。
-   包含大量其他的垃圾代码…

### 什么是可见性

可见性是对象“看到”或引用其他对象的能力

-   实现对象 A 到对象 B 的可见性通常有四种方式:
    -   属性可见性 Attribute Visibility：B 是 A 的属性。
    -   参数可见性 Parameter visibility：B 是 A 方法中的参数。
    -   局部可见性 Local Visibility：B 是 A 中方法的局部对象（不是参数）。
    -   全局可见性 Global Visibility：B 具有某种方式的全局可见性。
-   动机：为了使对象 A 能够向对象 B 发送消息，对于 A 而言，B 必须是可见的。

### 面向对象设计原则

-   单一职责原则
    -   类的职责要单一，不能将太多的职责放在一个类中
-   开闭原则
    -   软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能
-   里氏代换原则
    -   在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象
-   依赖倒转原则
    -   要针对抽象层编程，而不要针对具体类编程
-   接口隔离原则
    -   使用多个专门的接口来取代一个统一的接口
-   合成复用原则
    -   在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系
-   迪米特法则(选择)

### 在迪米特法则中，对于一个对象，其朋友

-   当前对象本身(this)；
-   以参数形式传入到当前对象方法中的对象；
-   当前对象的成员对象；
-   如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
-   当前对象所创建的对象
