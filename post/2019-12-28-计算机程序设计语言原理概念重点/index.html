<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>计算机程序设计语言原理概念重点 - Even - A super concise theme for Hugo</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zyuanlee"><meta name=description content="第一章——基本概念 语言的评价标准 可读性 可写性 可靠性 代价 可读性中正交性 使用该语言中一组相对少量的基本结构，经过少量的结合步骤，就可以构成该语言"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.85.0 with theme even"><link rel=canonical href=http://localhost:1313/post/2019-12-28-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E9%87%8D%E7%82%B9/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="计算机程序设计语言原理概念重点"><meta property="og:description" content="第一章——基本概念 语言的评价标准 可读性 可写性 可靠性 代价 可读性中正交性 使用该语言中一组相对少量的基本结构，经过少量的结合步骤，就可以构成该语言"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/2019-12-28-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E9%87%8D%E7%82%B9/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-12-28T20:28:19+00:00"><meta property="article:modified_time" content="2019-12-28T20:28:19+00:00"><meta itemprop=name content="计算机程序设计语言原理概念重点"><meta itemprop=description content="第一章——基本概念 语言的评价标准 可读性 可写性 可靠性 代价 可读性中正交性 使用该语言中一组相对少量的基本结构，经过少量的结合步骤，就可以构成该语言"><meta itemprop=datePublished content="2019-12-28T20:28:19+00:00"><meta itemprop=dateModified content="2019-12-28T20:28:19+00:00"><meta itemprop=wordCount content="3147"><meta itemprop=keywords content="期末复习,程序设计语言原理,"><meta name=twitter:card content="summary"><meta name=twitter:title content="计算机程序设计语言原理概念重点"><meta name=twitter:description content="第一章——基本概念 语言的评价标准 可读性 可写性 可靠性 代价 可读性中正交性 使用该语言中一组相对少量的基本结构，经过少量的结合步骤，就可以构成该语言"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Even</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Even</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>计算机程序设计语言原理概念重点</h1><div class=post-meta><span class=post-time>2019-12-28</span><div class=post-category><a href=/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/>课程学习</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#第一章基本概念>第一章——基本概念</a><ul><li><a href=#语言的评价标准>语言的评价标准</a></li><li><a href=#可读性中正交性>可读性中正交性</a></li><li><a href=#语言的分类>语言的分类</a></li><li><a href=#影响语言设计的因素>影响语言设计的因素</a></li></ul></li><li><a href=#第二章发展史>第二章——发展史</a></li><li><a href=#第五章名字绑定等>第五章——名字、绑定等</a><ul><li><a href=#关键字保留字与预定义名字>关键字、保留字与预定义名字</a></li><li><a href=#变量>变量</a></li><li><a href=#别名aliases>别名（aliases）</a></li><li><a href=#左值右值>左值、右值</a></li><li><a href=#类型>类型</a></li><li><a href=#抽象内存单元>抽象内存单元</a></li><li><a href=#绑定>绑定</a></li><li><a href=#存储绑定与生命周期>存储绑定与生命周期</a></li><li><a href=#类型检测>类型检测</a></li><li><a href=#类型强化>类型强化</a></li></ul></li><li><a href=#第六章数据类型>第六章——数据类型</a><ul><li><a href=#悬挂指针>悬挂指针</a></li></ul></li><li><a href=#第七章表达式与赋值语句>第七章——表达式与赋值语句</a><ul><li><a href=#操作符重载>操作符重载</a></li></ul></li><li><a href=#第九章子程序>第九章——子程序</a><ul><li><a href=#通用子程序特点general-subprogram-characteristics>通用子程序特点（General subprogram characteristics）</a></li><li><a href=#基本定义>基本定义</a></li><li><a href=#参数>参数</a></li><li><a href=#局部变量>局部变量</a></li><li><a href=#参数传递方法>参数传递方法</a></li><li><a href=#重载子程序>重载子程序</a></li><li><a href=#分别编译>分别编译</a></li><li><a href=#非局部全局变量>非局部、全局变量</a></li></ul></li><li><a href=#第十章实现子程序>第十章——实现子程序</a><ul><li><a href=#子程序链接>子程序链接</a></li><li><a href=#子程序调用过程>子程序调用过程</a></li><li><a href=#子程序的返回过程>子程序的返回过程</a></li></ul></li><li><a href=#第十一章抽象与封装>第十一章——抽象与封装</a><ul><li><a href=#基本抽象类型>基本抽象类型</a></li><li><a href=#封装>封装</a></li><li><a href=#抽象数据类型封装>抽象数据类型（封装）</a></li></ul></li><li><a href=#第十三章并发>第十三章——并发</a><ul><li><a href=#并发种类>并发种类</a></li><li><a href=#准并发>准并发</a></li><li><a href=#控制线thread-of-control>控制线（Thread of control）</a></li><li><a href=#同步>同步</a></li><li><a href=#信号量>信号量</a></li><li><a href=#会合rendezvous>会合（rendezvous）</a></li></ul></li><li><a href=#第十四章异常处理>第十四章——异常处理</a><ul><li><a href=#异常分类>异常分类</a></li><li><a href=#比较-adajava-与-c异常处理异同点>比较 Ada、java 与 C++异常处理异同点</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=第一章基本概念>第一章——基本概念</h2><h3 id=语言的评价标准>语言的评价标准</h3><ul><li>可读性</li><li>可写性</li><li>可靠性</li><li>代价</li></ul><h3 id=可读性中正交性>可读性中正交性</h3><ul><li>使用该语言中<strong>一组相对少量</strong>的基本结构，经过少量的结合步骤，就可以构成该语言的<strong>控制结构和数据结构</strong>，而且它的基本结构的任何组合都是合法和有意义的。</li></ul><h3 id=语言的分类>语言的分类</h3><ul><li>命令式语言</li><li>函数式语言</li><li>逻辑语言</li><li>面向对象语言</li></ul><h3 id=影响语言设计的因素>影响语言设计的因素</h3><ul><li>计算机体系结构</li><li>程序设计方法学</li></ul><h2 id=第二章发展史>第二章——发展史</h2><ul><li>第一个高级语言：Fortran</li><li>第一个具有结构化和接口化的语言：Algol 60</li><li>第一个面向对象的语言：SIMULA 67</li><li>美国国防部耗资巨大创建的语言：Ada</li><li>第一个纯面向对象的语言：Smalltalk</li><li>两个早期的动态语言：APL、SNOBOL</li></ul><h2 id=第五章名字绑定等>第五章——名字、绑定等</h2><h3 id=关键字保留字与预定义名字>关键字、保留字与预定义名字</h3><ul><li>关键字<ul><li>在特定的上下文中是特殊的</li><li>（Fortran 中，<code>real a</code>是声明语句，<code>a = 3.4</code>是赋值语句）</li><li>缺点：可读性差</li></ul></li><li>保留字<ul><li>一个特殊的字，不能作为用户自定义名字</li></ul></li><li>预定义名字<ul><li>介于关键字与保留字</li><li>有预定义的意义，但是能被用户重新定义</li></ul></li></ul><h3 id=变量>变量</h3><ul><li>是抽象的内存单元</li><li><strong>有六个属性：名字、地址、值、类型、生命周期与范围</strong>（匿名的无名字）</li></ul><h3 id=别名aliases>别名（aliases）</h3><ul><li><p>如果两个变量名字能访问同一内存地址，他们就被叫做别名</p></li><li><p>缺点</p><ul><li>可读性差</li><li>可靠性差</li></ul></li><li><p>别名如何被创造</p><ul><li>指针、引用变量、C 和 C ++联合</li><li>别名的某些原始理由不再有效</li><li>用动态分配替换它们</li></ul></li></ul><h3 id=左值右值>左值、右值</h3><ul><li><p>左值</p><ul><li>变量的内存地址</li></ul></li><li><p>右值</p><ul><li>变量的值</li></ul></li></ul><h3 id=类型>类型</h3><ul><li>决定变量值的范围</li><li>根据类型为变量设定操作集合</li><li>在浮点指针中，类型也决定精确度</li></ul><h3 id=抽象内存单元>抽象内存单元</h3><ul><li>单元格具有与其关联的变量所需的大小</li></ul><h3 id=绑定>绑定</h3><ul><li>是一种关联（属性和实体、操作和符号）</li><li><strong>静态绑定</strong><ul><li>它首次发生在运行前，并且整个程序运行过程中保持不变</li></ul></li><li><strong>动态绑定</strong><ul><li>它首次放生在运行时，或者在程序执行过程中可以改变</li></ul></li><li>显式声明<ul><li>一个被用作声明变量类型的说明语句</li></ul></li><li>隐式声明<ul><li>一个默认的机制，用来指明变量的类型</li></ul></li></ul><h3 id=存储绑定与生命周期>存储绑定与生命周期</h3><ul><li><p><strong>静态变量</strong></p><ul><li>在程序执行前绑定在存储单元，在整个执行过程中都绑定在同一存储单元的变量</li><li><strong>优点</strong><ul><li>高效、历史敏感</li></ul></li><li><strong>缺点</strong><ul><li>不灵活</li></ul></li></ul></li><li><p><strong>栈动态变量</strong></p><ul><li>当确立他们的声明语句时即产生了存储绑定，但它们的类型时静态绑定的变量</li><li>当子程序开始执行之时，才绑定到存储空间，并且执行终止时才解除这种绑定的变量</li></ul></li><li><p><strong>生命周期</strong></p><ul><li>该变量被绑定于某一特定存储地址的时间</li></ul></li></ul><h3 id=类型检测>类型检测</h3><ul><li><p>是保证一个操作符的所有操作数都具有相互兼容类型的措施</p><ul><li>兼容类型时对操作符而言为合法的类型，或者在语言规定的允许下，能够被编译器隐式转换为合法类型</li></ul></li><li><p><strong>类型错误</strong></p><ul><li>是将操作符作用于具有不适当类型的操作数</li><li>如果在一种语言中，所有变量类型的绑定都是静态的，那么几乎总是能够静态地进行类型检测</li><li>动态类型的绑定要求在运行时进行类型检测，这种类型检测被称为<strong>动态类型检测</strong></li></ul></li></ul><h3 id=类型强化>类型强化</h3><ul><li>只要某个程序设计语言总能够发现其程序中的类型错误，就定义这种程序设计语言为强类型的</li><li><strong>优点</strong><ul><li>能够发现所有因为变量的误用而导致的类型错误</li></ul></li></ul><h2 id=第六章数据类型>第六章——数据类型</h2><h3 id=悬挂指针>悬挂指针</h3><ul><li><p>是一个包含了已解除分配的堆动态变量地址的指针</p></li><li><p><strong>危害</strong></p><ul><li>悬挂指针指向的位置可能已经被重新分配给一个新的动态变量，新堆动态变量的值就会被破坏，存储管理的失败</li></ul></li><li><p>产生</p><ul><li>设指针 p1 指向一个新的堆动态变量</li><li>给指针 p2 赋以 p1 的值</li><li>将 p1 所指向的堆动态变量显式回收，并将 p1 变为 null，但是这种操作并不改变 p2，p2 现在成为一个悬挂指针。如果回收操作不改变 p1，p1 和 p2 都将是悬挂的</li></ul></li></ul><h2 id=第七章表达式与赋值语句>第七章——表达式与赋值语句</h2><h3 id=操作符重载>操作符重载</h3><ul><li><p>一个操作符的多种用途</p></li><li><p>危害</p><ul><li>影响可读性</li><li>有些问题编译器无法检测，如<code>x = a(a漏写) & b</code></li></ul></li></ul><h2 id=第九章子程序>第九章——子程序</h2><ul><li>一种程序设计语言可以包括两种基本的抽象设施<ul><li>过程抽象</li><li>数据抽象</li></ul></li></ul><h3 id=通用子程序特点general-subprogram-characteristics>通用子程序特点（General subprogram characteristics）</h3><ul><li>每一个子程序都有一个入口</li><li>在被调用的子程序执行期间，调用程序单元被停止执行，这意味着在任何给定时刻，只有一个子程序在执行</li><li>在子程序的结束时，总是将控制返回到调用程序</li></ul><h3 id=基本定义>基本定义</h3><ul><li><p><strong>参数描述（profile）</strong></p><ul><li>它所具有的形参数目、次序以及类型</li></ul></li><li><p><strong>协议</strong></p><ul><li>参数描述加上它的返回类型，如果它是函数</li></ul></li><li><p><strong>原型</strong></p><ul><li>子程序的声明</li></ul></li></ul><h3 id=参数>参数</h3><p>**形参：**子程序首部中的参数</p><p>**实参：**一组将与子程序中的形参相绑定的参数</p><p>**位置参数：**形参与实参的绑定是通过简单的位置进行的</p><p>**关键字参数：**将一个与实参相绑定的形参的名称与这个实参在一起被声明，如<code>post(url=post_url,data=post_data)</code> 缺点：使用人员必须知道形参的名字</p><h3 id=局部变量>局部变量</h3><ul><li>定义于子程序内部的变量</li></ul><h4 id=栈动态>栈动态</h4><ul><li><p>优</p><ul><li>为子程序提供了灵活性</li><li>与局部变量的存储空间可共享</li></ul></li><li><p>缺</p><ul><li>在存储空间分配、初始化、变量解除分配有时间花费</li><li>栈动态局部变量的存取必须是间接的</li><li>不是历史敏感的</li></ul></li></ul><h4 id=静态>静态</h4><ul><li><p>优</p><ul><li>高效，直接存取局部变量</li><li>分配与解除分配没有额外的时间代价</li><li>具有历史敏感敏感性</li></ul></li><li><p>缺</p><ul><li>不灵活，不支持递归运算</li><li>存储空间不能与局部变量共享</li></ul></li></ul><h3 id=参数传递方法>参数传递方法</h3><ul><li>按值传递</li><li>按结果传递</li><li>按值-结果传递</li><li>按引用传递</li><li>按名传递</li></ul><h3 id=重载子程序>重载子程序</h3><ul><li>是与另一个在相同引用环境中的子程序具有相同名称的子程序</li><li>它必须与子程序的其他版本在参数的数目、顺序、类型不相同</li><li>如果是一个函数，则是返回的类型不同</li></ul><h3 id=分别编译>分别编译</h3><ul><li>编译单元能在不同时间被编译，但是如果访问或使用其他实体，则编译不是独立的</li><li>为了提供分别编译的可靠性，编译器必须访问程序单元用到的，但是在别处声明的实体</li><li>通过独立编译，程序单元能在不知道其他程序单元的情况下被编译</li><li>最大特点<ul><li>在分别编译单元之间的接口不进行类型一致检查</li></ul></li></ul><h3 id=非局部全局变量>非局部、全局变量</h3><ul><li>局部变量<ul><li>在子程序中可见，但不是局部声明的</li></ul></li><li>全局变量<ul><li>在程序单元中都可见的变量</li></ul></li></ul><h2 id=第十章实现子程序>第十章——实现子程序</h2><h3 id=子程序链接>子程序链接</h3><ul><li>子程序的调用及返回操作的统称</li></ul><h3 id=子程序调用过程>子程序调用过程</h3><ol><li>如果局部变量是非静态的，它必须对局部变量进行存储空间分配，还要将这些变量与存储空间绑定</li><li>必须保留调用程序单元的执行状态</li><li>将控制转移到子程序的代码，并且在子程序结束后能保证将控制返回正确位置</li><li>提供对被调用子程序为可见的非局部变量的访问</li></ol><h3 id=子程序的返回过程>子程序的返回过程</h3><ol><li>将形参的局部值转移到相关联的实参上</li><li>解除分配局部变量占有的存储空间，并恢复调用程序的执行状态</li><li>将非局部引用的机制返回到调用之前的状态</li><li>必须将控制返回到调用程序</li></ol><h2 id=第十一章抽象与封装>第十一章——抽象与封装</h2><h3 id=基本抽象类型>基本抽象类型</h3><ul><li>过程抽象</li><li>数据抽象</li></ul><h3 id=封装>封装</h3><ul><li>将子程序与它们所用的数据组合</li><li>好处<ul><li>解决模块化问题</li><li>解决重新编译问题</li></ul></li></ul><h3 id=抽象数据类型封装>抽象数据类型（封装）</h3><ul><li>仅包含一种特定数据类型的数据表示形式，以及提供该类型操作的子程序</li><li>优点<ul><li>对抗复杂性的武器</li><li>一种使大型和/或复杂程序更易于管理的方法</li></ul></li><li>示例<ul><li>Ada 封装结构为——包</li><li>C++——类和结构</li><li>Java——类</li></ul></li></ul><h2 id=第十三章并发>第十三章——并发</h2><h3 id=并发种类>并发种类</h3><ul><li>物理并发<ul><li>有着多个处理器可供使用，并且来自相同程序的几个程序单位同时地运行</li></ul></li><li>逻辑并发<ul><li>程序是在一个处理器上被分时地执行</li></ul></li></ul><h3 id=准并发>准并发</h3><ul><li>具有协同（coroutines）的程序</li></ul><h3 id=控制线thread-of-control>控制线（Thread of control）</h3><ul><li>控制流经过程序时到达程序点的序列</li></ul><h3 id=同步>同步</h3><ul><li>合作同步<ul><li>当任务 A 在继续它的执行之前，它必须等待任务 B 完成某种特定活动</li></ul></li><li>竞争同步<ul><li>当两个任务都需要不可能同时使用的某种资源</li></ul></li></ul><h3 id=信号量>信号量</h3><ul><li>一种能够用来提供任务同步的简单机制<ul><li>一种数据结构</li><li>由一个整数和一个存储任务描述符的队列组成</li></ul></li></ul><h3 id=会合rendezvous>会合（rendezvous）</h3><ul><li>如果任务 A 需要发送一个消息给任务 B，并且任务 B 愿意接收，消息就能够被传递过来<ul><li>会合只会发生在发送者和接收者都希望它发生的时候</li></ul></li></ul><h2 id=第十四章异常处理>第十四章——异常处理</h2><h3 id=异常分类>异常分类</h3><ul><li>继续模型</li><li>终止模型</li><li>重试模型</li></ul><h3 id=比较-adajava-与-c异常处理异同点>比较 Ada、java 与 C++异常处理异同点</h3><ul><li>结构上<ul><li>Ada 采用<strong>EBNF</strong>的形式：<code>when 异常选择{|异常选择}=>语句序列</code></li><li>C++采用<strong>try-catch</strong>块</li><li>Java 采用<strong>try-catch</strong>块与<strong>finally</strong>语句</li></ul></li><li>引发语句<ul><li>Ada 采用<strong>raise[异常名]</strong></li><li>C++和 Java 采用<strong>throw[表达式]</strong></li></ul></li><li>传播方式<ul><li>Ada 中逐步向调用者上层去寻找，如果没有找到就自动结束</li><li>C++和 Java 中也是逐步向调用者上层去寻找，没找到就用默认处理方式</li></ul></li><li>匹配方式<ul><li>Ada 采用字符串匹配，属于类型匹配</li><li>C++和 Java 中除了类型匹配外，还进行最先匹配和最佳匹配方式</li></ul></li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>zyuanlee</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-12-28</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/>期末复习</a>
<a href=/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86/>程序设计语言原理</a></div><nav class=post-nav><a class=prev href=/post/2020-01-03_%E8%BD%AF%E5%B7%A5%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">软工常见模型</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/2019-12-24_-java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/><span class="next-text nav-default">java期末复习</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:your@email.com class="iconfont icon-email" title=email></a><a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a><a href=http://localhost:1313 class="iconfont icon-twitter" title=twitter></a><a href=http://localhost:1313 class="iconfont icon-facebook" title=facebook></a><a href=http://localhost:1313 class="iconfont icon-linkedin" title=linkedin></a><a href=http://localhost:1313 class="iconfont icon-google" title=google></a><a href=http://localhost:1313 class="iconfont icon-github" title=github></a><a href=http://localhost:1313 class="iconfont icon-weibo" title=weibo></a><a href=http://localhost:1313 class="iconfont icon-zhihu" title=zhihu></a><a href=http://localhost:1313 class="iconfont icon-douban" title=douban></a><a href=http://localhost:1313 class="iconfont icon-pocket" title=pocket></a><a href=http://localhost:1313 class="iconfont icon-tumblr" title=tumblr></a><a href=http://localhost:1313 class="iconfont icon-instagram" title=instagram></a><a href=http://localhost:1313 class="iconfont icon-gitlab" title=gitlab></a><a href=http://localhost:1313 class="iconfont icon-bilibili" title=bilibili></a><a href=http://localhost:1313/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2019 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>zyuanlee</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script></body></html>